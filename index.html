<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>HAMARUé¢¨ å˜èª4æŠï¼ˆCSV/å¾©ç¿’/å‘¨å›/çµæœ/éŸ³å£°/åˆ‡æ›¿ï¼‰</title>
  <style>
    :root { --bg:#0b1020; --card:#121a33; --text:#e8eeff; --muted:#a9b3d6; --good:#38d996; --bad:#ff5c7a; }
/* ã¾ãšå®‰å…¨ãªé«˜ã•åŸºæº–ã‚’ä½œã‚‹ */
:root { --vh: 1vh; }

/* ç”»é¢å…¨ä½“ã‚’ä½¿ã†æ‰€ã¯ 100vh ã§ã¯ãªãã“ã‚Œ */
.appHeight {
  min-height: calc(var(--vh) * 100);height: calc(var(--vh) * 100);
}


    body { margin:0; font-family: system-ui, -apple-system, Segoe UI, Roboto, "Noto Sans JP", sans-serif;
      background:radial-gradient(1200px 800px at 20% 0%, #1b2a66 0%, var(--bg) 55%); color:var(--text); }
    .wrap { max-width: 1020px; margin: 0 auto; padding: 20px; }
    .row { display:flex; gap:12px; flex-wrap:wrap; align-items:flex-start; justify-content:space-between; }
    .card { background: rgba(18,26,51,.88); border:1px solid rgba(255,255,255,.08); border-radius: 18px;
      box-shadow: 0 12px 30px rgba(0,0,0,.25); padding: 16px; }
    h1 { font-size: 18px; margin:0 0 10px; color: #dbe6ff; letter-spacing: .02em; }
    .hud { display:flex; gap:12px; flex-wrap:wrap; }
    .pill { background: rgba(255,255,255,.07); border:1px solid rgba(255,255,255,.08);
      padding: 10px 12px; border-radius: 14px; font-size: 13px; color: var(--muted); }
    .pill b { color: var(--text); }
    .big { font-size: 28px; font-weight: 800; letter-spacing: .02em; }
    .small { color: var(--muted); font-size: 13px; }
    .question { display:grid; gap:10px; }
    .qtop { display:flex; gap:10px; align-items:baseline; justify-content:space-between; }

    /* â‘¡ é•·æ–‡ã§ã‚‚è¦‹ã‚„ã™ãï¼šæŠ˜ã‚Šè¿”ã— + è‡ªå‹•ç¸®å°ç”¨ */
    #prompt {
      line-height: 1.18;
      word-break: break-word;
      overflow-wrap: anywhere;
    }
    .fit {
      font-size: clamp(18px, 3.3vw, 28px);
    }

    .progress { height: 10px; background: rgba(255,255,255,.08); border-radius: 99px; overflow:hidden;
      border:1px solid rgba(255,255,255,.08); }
    .bar { height:100%; width:100%; background: linear-gradient(90deg, rgba(56,217,150,.95), rgba(95,169,255,.9));
      transform-origin:left; }

    .choices { display:grid; grid-template-columns: 1fr; gap:10px; margin-top: 10px; }
    @media (min-width: 680px) { .choices { grid-template-columns: 1fr 1fr; } }

    button.choice {
      background: rgba(255,255,255,.06); border:1px solid rgba(255,255,255,.10); color: var(--text);
      border-radius: 16px; padding: 14px 14px; cursor:pointer; text-align:left;
      transition: transform .06s ease, background .2s ease, border-color .2s ease; user-select:none;
    }
    button.choice:hover { transform: translateY(-1px); background: rgba(255,255,255,.085); border-color: rgba(255,255,255,.16); }
    button.choice:active { transform: translateY(0px) scale(.99); }
    button.choice[disabled] { opacity:.72; cursor:not-allowed; }

    /* â‘¡ é¸æŠè‚¢ã‚‚é•·æ–‡å¯¾å¿œ */
    .choiceText {
      display:block;
      font-weight: 800;
      font-size: clamp(14px, 2.1vw, 16px);
      line-height: 1.22;
      word-break: break-word;
      overflow-wrap: anywhere;
    }

    .flash {
  border-radius: 16px;
  padding: 10px 12px;
  font-size: 16px;
  display: none;

  /* ä¸Šå›ºå®šã‚’ã‚„ã‚ã¦ã€ä»¥å‰ã®å ´æ‰€ï¼ˆå•é¡Œã®è¿‘ãï¼‰ã«æˆ»ã™ */
  position: static;
  transform: none;

  /* ç”»é¢ã‹ã‚‰ã¯ã¿å‡ºã•ãªã„ */
  width: 100%;
  max-width: 100%;
  box-sizing: border-box;
  white-space: normal;
  overflow-wrap: anywhere;

  /* ä»¥å‰ã®å ´æ‰€ã£ã½ãï¼šé¸æŠè‚¢ã®ä¸Šã§è¦‹ã‚„ã™ã */
  margin: 10px 0 0 0;
}
    .flash.good { display:block; background: rgba(56,217,150,.14); border:1px solid rgba(56,217,150,.35); color:#bff7df; }
    .flash.bad  { display:block; background: rgba(255,92,122,.12); border:1px solid rgba(255,92,122,.35); color:#ffd2db; }

    .controls { display:flex; gap:10px; flex-wrap:wrap; margin-top: 10px; }
    .btn {
      background: rgba(255,255,255,.08); border:1px solid rgba(255,255,255,.12); color: var(--text);
      border-radius: 14px; padding: 10px 12px; font-size: 13px; cursor:pointer;
    }
    .btn:hover { background: rgba(255,255,255,.10); }
    .btn.smallbtn { padding: 8px 10px; font-size: 12px; border-radius: 12px; }

    .settings { display:flex; gap:10px; flex-wrap:wrap; align-items:center; }
    input[type="number"], select, input[type="file"], input[type="range"] {
      padding: 9px 10px; border-radius: 12px; border:1px solid rgba(255,255,255,.14);
      background: rgba(0,0,0,.18); color: var(--text); outline:none;
    }
    input[type="number"] { width: 90px; }

    .footer { opacity:.9; margin-top: 10px; }
    .kbd { font-family: ui-monospace, SFMono-Regular, Menlo, monospace; background: rgba(255,255,255,.08);
      border:1px solid rgba(255,255,255,.10); padding: 2px 6px; border-radius: 8px; }
    .hint { opacity:.9; }
    .inline { display:flex; gap:10px; align-items:center; flex-wrap:wrap; }
    .spacer { height:12px; }
  
/* BIG flash message */
.flash{font-size:28px !important; line-height:1.2 !important; font-weight:800 !important; padding:14px 16px !important;}

    /* è¿½åŠ : è¨€èªãƒ•ã‚£ãƒ«ã‚¿ãƒ¼ã®ãƒãƒƒãƒ—ï¼ˆã‚¹ãƒãƒ›å‘ã‘ï¼‰ */
    .langchip{
      border:1px solid rgba(255,255,255,.16);
      background: rgba(255,255,255,.06);
      color: rgba(233,242,255,.92);
      padding:8px 10px;
      border-radius: 999px;
      font-weight: 800;
      cursor: pointer;
      user-select:none;
    }
    .langchip.on{
      border-color: rgba(47,209,132,.75);
      background: rgba(47,209,132,.18);
      color: rgba(233,242,255,.98);
    }

    /* è¿½åŠ : å…¨è§£é™¤ã®åå¿œã‚’åˆ†ã‹ã‚Šã‚„ã™ã */
    .langClearPulse{ transform: translateY(1px); filter: brightness(1.15); }

/* TTS HUD pill */
#ttsHudPill.free{ color:#cfd6ff; }
#ttsHudPill.active{ color:#38d996; }
#ttsHudPill.waiting{ color:#ff5c7a; }



/* ===== Mobile answer size (requested) ===== */
@media (max-width: 520px){
  .choices{ gap: 14px; }

  button.choice{
    padding: 22px 18px;
    border-radius: 18px;
  }

  /* Answer text size similar to your screenshot */
  .choiceText{
    font-size: clamp(26px, 6.5vw, 34px);
    line-height: 1.18;
    font-weight: 800;
    letter-spacing: .2px;
  }

  /* (1)(2)(3)(4) label */
  button.choice .small{
    font-size: 16px;
    opacity: .85;
  }
}


/* ===== Mobile layout tighten (HUD/Top area) ===== */
@media (max-width: 520px){
  h1{ margin-bottom: 6px; }
}

</style>
</head>

<body class="appHeight">
  <div class="wrap">
    <div class="row">
      <div class="card" style="flex: 1 1 600px;">
        <h1>HAMARUé¢¨ å˜èª4æŠï¼ˆCSV/å¾©ç¿’/å‘¨å›/çµæœ/éŸ³å£°/åˆ‡æ›¿ï¼‰</h1>

        <div class="hud">
          <div class="pill">ã‚¹ã‚³ã‚¢: <b id="score">0</b></div>
          <div class="pill">ã‚³ãƒ³ãƒœ: <b id="combo">0</b></div>
          <div class="pill">æ­£è§£ç‡: <b id="acc">0%</b></div>
          <div class="pill">æ®‹ã‚Š: <b id="remaining">0</b></div>
        
          <div class="pill" id="ttsHudPill">ğŸ™ éŸ³å£°: æœªä½¿ç”¨</div>
<button class="btn smallbtn" type="button" id="clearTtsLock">ğŸ”“ éŸ³å£°ãƒ­ãƒƒã‚¯è§£é™¤</button>


<div class="pill">CSV: <b id="csvHud">å†…è”µãƒ‡ãƒ¼ã‚¿</b></div>
<div class="pill">ä»Šæ—¥: <b id="dailyHud">0å• 0%</b> <span id="streakHud" class="small" style="margin-left:6px;">ğŸ”¥0</span></div>
        </div>

        <div class="spacer"></div>

        <div class="question">
          <!-- çµæœãƒ‘ãƒãƒ« -->
          <div id="resultPanel" class="card" style="display:none;margin-top:12px;">
            <div class="inline" style="justify-content:space-between;align-items:center;">
              <h1>çµæœï¼ˆé–“é•ãˆãŸé †ï¼‰</h1>
              <button class="btn smallbtn" type="button" id="closeResultTop">é–‰ã˜ã‚‹</button>
            </div>
            <div class="small" id="resultSummary"></div>
            <div class="settings" style="margin-top:8px;">
              <span class="small">è¡¨ç¤º: å‡ºé¡Œå›æ•°</span>
              <select id="resultMinSeen">
                <option value="1">1å›ä»¥ä¸Šï¼ˆå…¨éƒ¨ï¼‰</option>
                <option value="3">3å›ä»¥ä¸Š</option>
                <option value="5" selected>5å›ä»¥ä¸Š</option>
              </select>
              <button class="btn" id="autoPickWeakFromResults">ã“ã®æ¡ä»¶ã§è‹¦æ‰‹ã‚’è‡ªå‹•ã‚»ãƒƒãƒˆ</button>
            </div>
            <div style="height:10px"></div>
            <div id="resultTable" class="small" style="overflow:auto;"></div>
            <div style="height:10px"></div>
            <button class="btn" type="button" id="closeResult">é–‰ã˜ã‚‹</button>
          </div>

          <div class="qtop">
            <div>
              <div class="inline">
                <div class="small" id="modeLabel">æ—¥æœ¬èª â†’ è‹±èªï¼ˆ4æŠï¼‰</div>
                <button class="btn smallbtn" type="button" id="speak">ğŸ”Š ç™ºéŸ³</button>
                <button class="btn smallbtn" type="button" id="stopSpeak">â¹ åœæ­¢</button>
                
              </div>
              <div class="big fit" id="prompt">---</div>
              <div class="small hint" id="ttsHint"></div>
            </div>
            <div style="text-align:right">
              <div class="small">åˆ¶é™æ™‚é–“</div>
              <div class="big"><span id="time">0.0</span>s</div>
            </div>
          </div>

          <div class="progress">
            <div class="bar" id="bar"></div>
          </div>

          <div id="flash" class="flash"></div>
          <div class="choices" id="choices"></div>

          <div class="controls">
            <button class="btn" type="button" id="skip">ã‚¹ã‚­ãƒƒãƒ—ï¼ˆå¾©ç¿’ã«å›ã™ï¼‰</button>
            <button class="btn" type="button" id="restart">ãƒªã‚¹ã‚¿ãƒ¼ãƒˆ</button>
            <button class="btn" type="button" id="showResultsBtn">çµæœã‚’è¦‹ã‚‹</button>
            <button class="btn" type="button" id="pauseBtn">â¸ ä¸€æ™‚åœæ­¢</button>
          </div>

          <div class="footer small">
            ã‚·ãƒ§ãƒ¼ãƒˆã‚«ãƒƒãƒˆ:
            <span class="kbd">1</span>ã€œ<span class="kbd">4</span>ã§é¸æŠ /
            <span class="kbd">S</span>ã§ã‚¹ã‚­ãƒƒãƒ— /
            <span class="kbd">R</span>ã§ãƒªã‚¹ã‚¿ãƒ¼ãƒˆ /
            <span class="kbd">P</span>ã§ç™ºéŸ³ /
            <span class="kbd">X</span>ã§åœæ­¢
          </div>
        </div>
      </div>

      <div class="card" style="flex: 1 1 360px;">
        <h1>è¨­å®š</h1>

        <div class="spacer"></div>

        <div class="card" style="background:rgba(255,255,255,.04); border:1px solid rgba(255,255,255,.08);">
          <h1 style="font-size:16px;margin:0 0 8px;">ğŸ“… å­¦ç¿’ãƒ­ã‚°ï¼ˆã“ã®CSVï¼‰</h1>
          <div class="small" id="dailySummaryLine">ä»Šæ—¥: --</div>
          <div class="small" id="streakLine" style="margin-top:4px;">é€£ç¶š: --</div>
          <div class="inline" style="margin-top:10px; gap:8px; flex-wrap:wrap;">
            <button class="btn smallbtn" type="button" id="toggleDailyPanel">å±¥æ­´ã‚’è¦‹ã‚‹</button>
            <button class="btn smallbtn" type="button" id="resetToday">ä»Šæ—¥ã‚’ãƒªã‚»ãƒƒãƒˆ</button>
          </div>
          <div id="dailyPanel" class="card" style="display:none; margin-top:10px; padding:12px;">
            <div class="small" style="opacity:.92; margin-bottom:6px;">ç›´è¿‘ã®å±¥æ­´ï¼ˆæœ€å¤§30æ—¥ï¼‰</div>
            <div id="dailyHistory" class="small" style="max-height:220px; overflow:auto;"></div>
          </div>
          <div class="small" style="opacity:.8; margin-top:8px;">
            â€»ã“ã®ãƒ­ã‚°ã¯ã€Œã“ã®CSVã ã‘ã€ã«ä¿å­˜ã•ã‚Œã¾ã™ï¼ˆä»–CSVã¨ã¯åˆ¥ï¼‰<br/>
            â€»ã€Œä»Šæ—¥ã‚’ãƒªã‚»ãƒƒãƒˆã€ã¯ã“ã®CSVã®â€œä»Šæ—¥åˆ†â€ã ã‘0ã«ã—ã¾ã™
          </div>
        </div>


        <!-- â‘¢ æ–¹å‘åˆ‡æ›¿ -->
        <div class="settings">
          <label class="small">å‡ºé¡Œæ–¹å‘</label>
          <select id="direction">
            <option value="ja2en">æ—¥æœ¬èª â†’ è‹±èª</option>
            <option value="en2ja">è‹±èª â†’ æ—¥æœ¬èª</option>
          </select>
        </div>

        <div class="spacer"></div>

        <div class="settings">
          <label class="small">1å•ã®æ™‚é–“ï¼ˆç§’ï¼‰</label>
          <input id="secondsPerQ" type="number" min="1" max="30" step="0.5" value="6" />
        </div>

        <div class="spacer"></div>

        <div class="settings">
          <label class="small">å‡ºé¡Œã™ã‚‹è¨€èªï¼ˆlangãƒ•ã‚£ãƒ«ã‚¿ãƒ¼ï¼‰</label>
          <div class="small" style="opacity:.9; margin-bottom:6px;">
            CSVã« <span class="kbd">lang</span> åˆ—ã‚’å…¥ã‚Œã‚‹ã¨ã€ã“ã“ã§è¨€èªã‚’é¸ã‚“ã åˆ†ã ã‘å‡ºé¡Œã—ã¾ã™ï¼ˆæ··ã–ã‚Šé˜²æ­¢ï¼‰ã€‚
          </div>
          <select id="langFilter" multiple style="display:none;"></select>
<div id="langChips" style="display:flex;flex-wrap:wrap;gap:8px;"></div>
          <div class="inline" style="gap:8px; margin-top:8px; flex-wrap:wrap;">
            <button class="btn smallbtn" type="button" id="langAll">å…¨é¸æŠ</button>
            <button class="btn smallbtn" type="button" id="langClear">å…¨è§£é™¤</button>
          </div>

          <div class="inline" style="gap:8px; margin-top:8px; flex-wrap:wrap; align-items:center;">
            <span class="small" style="opacity:.9;">ğŸ™ éŸ³å£°ãƒ¢ãƒ¼ãƒ‰</span>
            <select id="voiceMode" class="smallbtn" style="padding:8px 10px;">
              <option value="auto">è‡ªå‹•ï¼ˆãŠã™ã™ã‚ï¼‰</option>
              <option value="local">ãƒ­ãƒ¼ã‚«ãƒ«ã®ã¿</option>
              <option value="online">ã‚ªãƒ³ãƒ©ã‚¤ãƒ³ã®ã¿</option>
            </select>
            <span class="small" style="opacity:.75;">â€»ã‚ªãƒ³ãƒ©ã‚¤ãƒ³ã¯ãƒãƒƒãƒˆå¿…é ˆ</span>
          </div>
          <div class="small" id="langFilterStatus" style="opacity:.9; margin-top:6px;">è¨€èª: ã™ã¹ã¦</div>
        </div>
        <div class="spacer"></div>

        <div class="settings">
          <label class="small">å‘¨å›æ•°</label>
          <select id="rounds">
            <option value="1">1å‘¨</option>
            <option value="2">2å‘¨</option>
            <option value="3">3å‘¨</option>
            <option value="5">5å‘¨</option>
            <option value="10">10å‘¨</option>
            <option value="inf">âˆï¼ˆçµ‚ã‚ã‚‰ãªã„ï¼‰</option>
          </select>
        </div>

        <div class="spacer"></div>

        <div class="settings">
          <label class="small">å¾©ç¿’ã®ã—ã¤ã“ã•ï¼ˆâˆç”¨ï¼‰</label>
          <input id="reviewWeight" type="number" min="1" max="10" step="1" value="5" />
        </div>

        <div class="spacer"></div>

        <div class="settings">
          <label class="small">ãƒ‡ãƒƒã‚­</label>
          <select id="deckSelect">
            <option value="all">å…¨éƒ¨</option>
            <option value="1">Lv1</option>
            <option value="2">Lv2</option>
            <option value="3">Lv3</option>
            <option value="12">Lv1+Lv2</option>
            <option value="23">Lv2+Lv3</option>
          </select>
        </div>
        <div class="small" id="deckStatus" style="margin-top:8px;opacity:.9;"></div>

        <hr style="border:none;border-top:1px solid rgba(255,255,255,.10);margin:12px 0;">

        <h1 style="font-size:16px;margin:0 0 8px;">å¾©ç¿’ãƒ¢ãƒ¼ãƒ‰</h1>

        <div class="settings">
          <label class="small">å¾©ç¿’ãƒ¢ãƒ¼ãƒ‰</label>
          <select id="reviewMode">
            <option value="off">OFF</option>
            <option value="on">ONï¼ˆé¸ã‚“ã èªã‚’ãƒ«ãƒ¼ãƒ—ï¼‰</option>
          </select>
        </div>

        <div class="spacer"></div>

        <div class="settings">
          <label class="small">å¾©ç¿’èªæ•°</label>
          <input id="reviewCount" type="number" min="4" max="50" step="1" value="10" />
        </div>

        <div class="spacer"></div>

      <div class="settings">
  <button class="btn" type="button" id="pickReview">å¾©ç¿’èªã‚’é¸ã¶ï¼ˆãƒã‚§ãƒƒã‚¯ï¼‰</button>
  <button class="btn" type="button" id="autoPickWeak">è‹¦æ‰‹ã‚’è‡ªå‹•ã‚»ãƒƒãƒˆ</button>
  <button class="btn" type="button" id="autoPickWeakGlobal">å…¨CSVã‹ã‚‰è‹¦æ‰‹ã‚’è‡ªå‹•ã‚»ãƒƒãƒˆ</button>
  <button class="btn" type="button" id="openGlobalWeak">ç·åˆ è‹¦æ‰‹ãƒ©ãƒ³ã‚­ãƒ³ã‚°</button>
  <button class="btn" type="button" id="clearReview">å¾©ç¿’ã‚’ã‚¯ãƒªã‚¢</button>
            <button class="btn" type="button" id="resetStats">ãƒ©ãƒ³ã‚­ãƒ³ã‚°åˆæœŸåŒ–</button>
</div>

<div class="settings" style="margin-top:10px;">
  <label class="small">è‹¦æ‰‹åˆ¤å®šï¼ˆæ­£è§£ç‡% æœªæº€ï¼‰</label>
  <input id="weakThreshold" type="number" min="0" max="100" step="1" value="30" />
</div>
  







        <div class="small" id="reviewStatus" style="margin-top:8px;opacity:.9;"></div>

        <div id="reviewPanel" class="card" style="display:none;margin-top:10px;padding:12px;">
          <div class="small" style="margin-bottom:8px;">å¾©ç¿’ã—ãŸã„å˜èªã«ãƒã‚§ãƒƒã‚¯ï¼ˆæœ€å¤§ <span id="reviewMax">10</span>ï¼‰</div>
          <div id="reviewList" style="max-height:220px;overflow:auto;"></div>
          <div style="height:10px"></div>
          <button class="btn" type="button" id="saveReview">ä¿å­˜ã—ã¦é–‰ã˜ã‚‹</button>
        </div>

        <hr style="border:none;border-top:1px solid rgba(255,255,255,.10);margin:12px 0;">

        <h1 style="font-size:16px;margin:0 0 8px;">éŸ³å£°ï¼ˆTTSï¼‰</h1>

        <!-- â‘  æ­£è§£æ™‚ã®è‡ªå‹•ç™ºéŸ³ -->
        <div class="settings">
          <label class="small">è‹±â†’æ—¥ï¼ˆå•é¡Œè¡¨ç¤ºæ™‚ï¼‰ã«è‡ªå‹•ç™ºéŸ³</label>
          <select id="autoSpeak">
            <option value="on">ON</option>
            <option value="off">OFF</option>
          </select>
        </div>

        <div class="spacer"></div>

        <div class="settings">
          <label class="small">å£°ï¼ˆè‡ªå‹•é¸æŠï¼‰</label>
          <select id="voiceSelect"></select>
        </div>

        <div class="spacer"></div>

        <div class="settings">
          <label class="small">é€Ÿã•</label>
          <input id="rate" type="range" min="0.7" max="1.2" step="0.05" value="1.0" />
          <span class="small" id="rateLabel">1.00</span>
        </div>

        <div class="spacer"></div>

        <div class="settings">
          <label class="small">éŸ³é‡</label>
          <input id="volume" type="range" min="0" max="1" step="0.05" value="1.0" />
          <span class="small" id="volLabel">1.00</span>
        </div>

        <hr style="border:none;border-top:1px solid rgba(255,255,255,.10);margin:12px 0;">

        <div class="settings">
          <label class="small">CSVã‚’èª­ã¿è¾¼ã¿</label>
          <input id="csvFile" type="file" accept=".csv,text/csv" />
          <button class="btn smallbtn" type="button" id="forgetLastCsv">ğŸ§¹ å‰å›CSVã‚’å¿˜ã‚Œã‚‹</button>
          <div class="small" id="lastCsvStatus" style="margin-top:6px;opacity:.85;"></div>
        </div>
        <div class="small" id="csvStatus" style="margin-top:8px;opacity:.9;"></div>

        <div style="margin-top:10px" class="small">
          CSVå½¢å¼: <span class="kbd">en,ja,level</span><br/>
          en = è‹±èª / ja = æ—¥æœ¬èª / level = 1ã€œ3ï¼ˆä»»æ„ï¼‰
        </div>
      </div>
    </div>
  </div>
        <!-- CSVä¸Šæ›¸ãæ™‚ï¼šæˆç¸¾ã®å¼•ãç¶™ãé¸æŠï¼ˆãƒãƒƒã‚·ãƒ¥ãŒå¤‰ã‚ã£ãŸã¨ãï¼‰ -->
        <div id="overwritePanel" style="display:none; position:fixed; inset:0; background:rgba(0,0,0,.55); padding:18px; z-index:9999; overflow:auto;">
          <div class="card" style="max-width:760px;margin:0 auto;">
            <h1 style="font-size:16px;margin:0 0 8px;">CSVãŒæ›´æ–°ã•ã‚ŒãŸã¿ãŸã„</h1>
            <div class="small" id="overwriteInfo" style="opacity:.92;"></div>
            <div class="spacer"></div>

            <div class="small" style="opacity:.9;">
              ã©ã®æˆç¸¾ã‚’ä½¿ã†ï¼Ÿï¼ˆã‚ã¨ã§ç®¡ç†ç”»é¢ã§åˆ‡æ›¿ã‚‚ã§ãã‚‹ã‚ˆã†ã«æ‹¡å¼µå¯èƒ½ï¼‰
            </div>
            <div class="spacer"></div>

            <div class="inline">
              <button class="btn" id="btnInheritAll">å¼•ãç¶™ãï¼ˆå…¨éƒ¨ï¼‰</button>
              <button class="btn" id="btnMergeCommon">éƒ¨åˆ†ãƒãƒ¼ã‚¸ï¼ˆå…±é€šå˜èªã ã‘ï¼‰</button>
              <button class="btn" id="btnResetNew">ãƒªã‚»ãƒƒãƒˆï¼ˆæ–°ã—ãé–‹å§‹ï¼‰</button>
              <button class="btn smallbtn" id="btnCancelLoad">ã‚­ãƒ£ãƒ³ã‚»ãƒ«</button>
            </div>

            <div class="spacer"></div>
            <div class="small" style="opacity:.85;">
              â€»ã€Œå¼•ãç¶™ãã€ã¯å‰ã®æˆç¸¾ã‚’ãã®ã¾ã¾æ–°CSVã«ã‚³ãƒ”ãƒ¼ã—ã¾ã™ã€‚<br/>
              â€»ã€Œéƒ¨åˆ†ãƒãƒ¼ã‚¸ã€ã¯æ–°CSVã«å­˜åœ¨ã™ã‚‹å˜èªã ã‘æˆç¸¾ã‚’æŒã£ã¦ãã¾ã™ï¼ˆå¤ã„å˜èªã¯æ¨ã¦ã‚‹ï¼‰ã€‚<br/>
              â€»ã€Œãƒªã‚»ãƒƒãƒˆã€ã¯æ–°CSVã®æˆç¸¾ã‚’0ã‹ã‚‰å§‹ã‚ã¾ã™ï¼ˆå¤ã„æˆç¸¾ã¯æ®‹ã‚‹ã®ã§ã€å¾Œã§æˆ»ã™ã“ã¨ã‚‚å¯èƒ½ï¼‰ã€‚
            </div>
          </div>
        
        </div>

<!-- ç·åˆ è‹¦æ‰‹ãƒ©ãƒ³ã‚­ãƒ³ã‚°ï¼ˆå…¨CSVæ¨ªæ–­ï¼‰ -->
        <div id="globalWeakPanel" style="display:none; position:fixed; inset:0; background:rgba(0,0,0,.55); padding:18px; z-index:9999; overflow:auto;">
          <div class="card" style="max-width:900px;margin:0 auto;">
            <div class="inline" style="justify-content:space-between;align-items:center;">
              <h1 style="font-size:16px;margin:0;">ç·åˆ è‹¦æ‰‹ãƒ©ãƒ³ã‚­ãƒ³ã‚°ï¼ˆå…¨CSVæ¨ªæ–­ï¼‰</h1>
              <button class="btn smallbtn" type="button" id="closeGlobalWeak">é–‰ã˜ã‚‹</button>
            </div>
            <div class="small" style="opacity:.9;margin-top:6px;">
              â€»å˜èªã‚­ãƒ¼ã¯ <span class="kbd">en||ja||level</span> ã§åˆç®—ï¼ˆåŒã˜å˜èªã¯å…¨éƒ¨ã¾ã¨ã‚ã‚‹ï¼‰
            </div>

            <div class="spacer"></div>

            <div class="settings">
              <label class="small">é›†è¨ˆæ¡ä»¶ï¼ˆå‡ºé¡Œå›æ•°ãŒã“ã‚Œæœªæº€ã¯é™¤å¤–ï¼‰</label>
              <input id="globalMinSeen" type="number" min="1" max="9999" step="1" value="5" />
            </div>

            <div class="spacer"></div>

            <div class="settings">
              <label class="small">è‹¦æ‰‹åˆ¤å®šï¼ˆæ­£è§£ç‡% æœªæº€ï¼‰</label>
              <input id="globalWeakThreshold" type="number" min="0" max="100" step="1" value="30" />
            </div>

            <div class="spacer"></div>

            <div class="settings">
              <button class="btn" type="button" id="refreshGlobalWeak">ãƒ©ãƒ³ã‚­ãƒ³ã‚°æ›´æ–°</button>
              <button class="btn" type="button" id="applyGlobalWeakToReview">ã“ã®æ¡ä»¶ã§å…¨CSVè‹¦æ‰‹ã‚’å¾©ç¿’ã‚»ãƒƒãƒˆã«ã™ã‚‹</button>
              <button class="btn" type="button" id="loadGlobalReview">ä¿å­˜ã—ãŸç·åˆå¾©ç¿’ã‚’èª­ã¿è¾¼ã‚€</button>
            </div>
            <div id="globalFlash" class="flash" style="display:none; margin-top:10px;"></div>


            <div class="small" id="globalWeakInfo" style="margin-top:8px;opacity:.9;"></div>
            <div style="height:10px"></div>

            <div id="globalWeakList" style="max-height:420px;overflow:auto;"></div>
          </div>
        </div>


<script>

// ===== TTS LOCK (stale-safe) =====
// éŸ³å£°ã¯ã€ŒåŒã˜ãƒ–ãƒ©ã‚¦ã‚¶å†…ã®åˆ¥ã‚¿ãƒ–ã€ã¨ç«¶åˆã—ã‚„ã™ã„ã®ã§ã€localStorageã§ç°¡æ˜“ãƒ­ãƒƒã‚¯ã—ã¾ã™ã€‚
// ãŸã ã—ã€ã‚¿ãƒ–ãŒã‚¯ãƒ©ãƒƒã‚·ãƒ¥/å¼·åˆ¶çµ‚äº†ã™ã‚‹ã¨è§£æ”¾ã•ã‚Œãªã„ã“ã¨ãŒã‚ã‚‹ãŸã‚ã€TTLï¼ˆæœŸé™ï¼‰ã¨å¿ƒæ‹ã§è‡ªå‹•å¾©æ—§ã—ã¾ã™ã€‚
const TTS_LOCK_KEY = "hamaru_tts_lock";
const TAB_ID = Math.random().toString(36).slice(2);
const LOCK_TTL_MS = 12000;     // 12ç§’ã§æœŸé™åˆ‡ã‚Œæ‰±ã„
const HEARTBEAT_MS = 3000;     // æ‰€æœ‰ä¸­ã¯3ç§’ã”ã¨ã«æ›´æ–°

function _now(){ return Date.now(); }

function _readLock(){
  try{
    const raw = localStorage.getItem(TTS_LOCK_KEY);
    if(!raw) return null;
    // æ—§å½¢å¼ï¼ˆæ–‡å­—åˆ—ã®ã¿ï¼‰ã‚‚æ•‘æ¸ˆ
    if(raw && raw[0] !== "{"){
      return { id: raw, ts: _now() };
    }
    const obj = JSON.parse(raw);
    if(!obj || !obj.id) return null;
    // ts ãŒç„¡ã„/å£Šã‚Œã¦ã‚‹å ´åˆã¯å³æœŸé™åˆ‡ã‚Œæ‰±ã„
    if(!obj.ts || (_now() - obj.ts) > LOCK_TTL_MS) return null;
    return obj;
  }catch(e){
    return null;
  }
}

function _writeLock(){
  try{
    localStorage.setItem(TTS_LOCK_KEY, JSON.stringify({ id: TAB_ID, ts: _now() }));
  }catch(e){}
}

let __ttsHeartbeat = null;
function _startHeartbeat(){
  try{ if(__ttsHeartbeat) return; }catch(e){}
  __ttsHeartbeat = setInterval(()=>{
    try{
      const lock = _readLock();
      if(lock && lock.id === TAB_ID){
        _writeLock(); // æ›´æ–°
      }else{
        // ã‚‚ã†æ‰€æœ‰ã—ã¦ãªã„ãªã‚‰åœæ­¢
        try{ clearInterval(__ttsHeartbeat); }catch(e){}
        __ttsHeartbeat = null;
      }
    }catch(e){}
  }, HEARTBEAT_MS);
}

function acquireTtsLock(){
  const lock = _readLock();
  if(!lock || lock.id === TAB_ID){
    _writeLock();
    _startHeartbeat();
    return true;
  }
  // æœŸé™åˆ‡ã‚Œã¯ _readLock ãŒ null ã‚’è¿”ã™ã®ã§ã€ã“ã“ã«æ¥ã‚‹ã®ã¯ã€Œä»–ã‚¿ãƒ–ãŒç”Ÿãã¦ã‚‹ã€æ™‚
  return false;
}

function releaseTtsLock(){
  try{
    const raw = localStorage.getItem(TTS_LOCK_KEY);
    if(!raw) return;
    if(raw && raw[0] !== "{"){
      // æ—§å½¢å¼
      if(raw === TAB_ID) localStorage.removeItem(TTS_LOCK_KEY);
    }else{
      const obj = JSON.parse(raw);
      if(obj && obj.id === TAB_ID) localStorage.removeItem(TTS_LOCK_KEY);
    }
  }catch(e){}
  try{ if(__ttsHeartbeat) clearInterval(__ttsHeartbeat); }catch(e){}
  __ttsHeartbeat = null;
}

// ã‚¿ãƒ–ã‚’é–‰ã˜ã‚‹/ç§»å‹•ã™ã‚‹ã‚¿ã‚¤ãƒŸãƒ³ã‚°ã§è§£æ”¾
window.addEventListener("beforeunload", () => {
  try{ releaseTtsLock(); }catch(e){}
});

// ã‚¹ãƒãƒ›å¯¾ç­–ï¼šãƒãƒƒã‚¯ã‚°ãƒ©ã‚¦ãƒ³ãƒ‰ã¸è¡Œãã¨ beforeunload ãŒèµ°ã‚‰ãªã„ã“ã¨ãŒã‚ã‚‹
document.addEventListener("visibilitychange", () => {
  if(document.hidden){
    // hiddenæ™‚ã¯åœæ­¢ãƒœã‚¿ãƒ³ç›¸å½“ï¼ˆèª­ã¿ä¸Šã’ã‚‚æ­¢ã‚ã‚‹ï¼‰
    try{ window.speechSynthesis && window.speechSynthesis.cancel(); }catch(e){}
    try{ releaseTtsLock(); }catch(e){}
  }
});

// =========================
  // åˆæœŸå˜èªï¼ˆè‹±èªï¼‰
  // en = è‹±èª, ja = æ—¥æœ¬èª
  // =========================
  let WORDS_ALL = [
    { en:"hello", ja:"ã“ã‚“ã«ã¡ã¯", level:1 },
    { en:"thank you", ja:"ã‚ã‚ŠãŒã¨ã†", level:1 },
    { en:"sorry", ja:"ã”ã‚ã‚“ãªã•ã„", level:1 },
    { en:"please", ja:"ãŠé¡˜ã„ã—ã¾ã™", level:1 },
    { en:"yes", ja:"ã¯ã„", level:1 },
    { en:"no", ja:"ã„ã„ãˆ", level:1 },
    { en:"today", ja:"ä»Šæ—¥", level:1 },
    { en:"tomorrow", ja:"æ˜æ—¥", level:1 },
    { en:"yesterday", ja:"æ˜¨æ—¥", level:1 },
    { en:"now", ja:"ä»Š", level:1 },
    { en:"where", ja:"ã©ã“", level:1 },
    { en:"what", ja:"ãªã«", level:1 },
    { en:"how", ja:"ã©ã†", level:1 },
    { en:"why", ja:"ãªãœ", level:2 },
    { en:"friend", ja:"å‹é”", level:1 },
    { en:"family", ja:"å®¶æ—", level:1 },
    { en:"school", ja:"å­¦æ ¡", level:1 },
    { en:"work", ja:"ä»•äº‹", level:1 },
    { en:"eat", ja:"é£Ÿã¹ã‚‹", level:1 },
    { en:"drink", ja:"é£²ã‚€", level:1 },

    { en:"interesting", ja:"é¢ç™½ã„", level:2 },
    { en:"difficult", ja:"é›£ã—ã„", level:2 },
    { en:"easy", ja:"ç°¡å˜", level:1 },
    { en:"careful", ja:"æ³¨æ„æ·±ã„", level:2 },
    { en:"familiar", ja:"ã‚ˆãçŸ¥ã£ã¦ã„ã‚‹ï¼æ…£ã‚Œã¦ã„ã‚‹", level:2 },
    { en:"coincidence", ja:"å¶ç„¶", level:3 },
    { en:"insurance", ja:"ä¿é™º", level:3 },

    { en:"watch out", ja:"æ°—ã‚’ã¤ã‘ã¦ï¼", level:2 },
    { en:"wait a second", ja:"ã¡ã‚‡ã£ã¨å¾…ã£ã¦", level:2 },
    { en:"no problem", ja:"å•é¡Œãªã„ã‚ˆ", level:1 },
    { en:"take away", ja:"æŒã£ã¦ã„ãï¼å–ã‚Šé™¤ã", level:2 },
  ];

  WORDS_ALL = WORDS_ALL.map(w => ({...w, lang: w.lang || w.en_lang || 'en-US'}));
  let WORDS = WORDS_ALL.slice();
  let CURRENT_CSV_NAME = "å†…è”µãƒ‡ãƒ¼ã‚¿";
  let CURRENT_CSV_HASH = "builtin"; // CSVå†…å®¹ãƒ™ãƒ¼ã‚¹ã®æŒ‡ç´‹ï¼ˆSHA-256ï¼‰

  // =========================
  // Daily learning log (per CSV hash) âœ… ä»Šæ—¥ / å±¥æ­´ / é€£ç¶š
  // =========================
  const DAILY_PREFIX = "hamaru_daily_v1::";           // per day + csvhash
  const DAILY_HISTORY_PREFIX = "hamaru_daily_hist_v1::"; // per csvhash list
  let DAILY = { date:"", seen:0, correct:0, wrong:0, skip:0, updatedAt:0 };

  function jstDateKey(d=new Date()){
    try{
      // "sv-SE" -> YYYY-MM-DD
      return new Intl.DateTimeFormat("sv-SE",{ timeZone:"Asia/Tokyo", year:"numeric", month:"2-digit", day:"2-digit" }).format(d);
    }catch(e){
      // fallback (local)
      return d.toISOString().slice(0,10);
    }
  }
  function dailyKeyFor(hash, date){ return `${DAILY_PREFIX}${hash}::${date}`; }
  function dailyHistoryKeyFor(hash){ return `${DAILY_HISTORY_PREFIX}${hash}`; }

  function loadDailyForCurrent(){
    const date = jstDateKey();
    DAILY.date = date;
    try{
      const raw = localStorage.getItem(dailyKeyFor(CURRENT_CSV_HASH, date));
      if(raw){
        const obj = JSON.parse(raw);
        DAILY = { date, seen: Number(obj.seen||0), correct:Number(obj.correct||0), wrong:Number(obj.wrong||0), skip:Number(obj.skip||0), updatedAt:Number(obj.updatedAt||0) };
      }else{
        DAILY = { date, seen:0, correct:0, wrong:0, skip:0, updatedAt:0 };
      }
    }catch(e){
      DAILY = { date, seen:0, correct:0, wrong:0, skip:0, updatedAt:0 };
    }
    renderDailyUI();
  }

  function saveDaily(){
    try{
      DAILY.updatedAt = Date.now();
      localStorage.setItem(dailyKeyFor(CURRENT_CSV_HASH, DAILY.date), JSON.stringify(DAILY));
    }catch(e){}
  }

  function loadDailyHistory(){
    try{
      const raw = localStorage.getItem(dailyHistoryKeyFor(CURRENT_CSV_HASH));
      const arr = raw ? JSON.parse(raw) : [];
      return Array.isArray(arr) ? arr : [];
    }catch(e){
      return [];
    }
  }

  function saveDailyHistory(arr){
    try{ localStorage.setItem(dailyHistoryKeyFor(CURRENT_CSV_HASH), JSON.stringify(arr||[])); }catch(e){}
  }

  function upsertTodayInHistory(){
    const arr = loadDailyHistory();
    const date = DAILY.date;
    const rec = {
      date,
      csvName: CURRENT_CSV_NAME || "ï¼ˆä¸æ˜ï¼‰",
      seen: DAILY.seen, correct: DAILY.correct, wrong: DAILY.wrong, skip: DAILY.skip
    };
    const out = [rec, ...arr.filter(x => x && x.date !== date)];
    saveDailyHistory(out.slice(0, 30));
  }

  function calcStreak(){
    const arr = loadDailyHistory().slice().sort((a,b)=> String(b.date).localeCompare(String(a.date)));
    if(!arr.length) return 0;

    // index by date for fast lookup
    const map = new Map();
    for(const r of arr){
      if(r && r.date) map.set(String(r.date), r);
    }

    let streak = 0;
    let d = new Date();
    for(let i=0; i<366; i++){
      const key = jstDateKey(d);
      const r = map.get(key);
      if(r && Number(r.seen||0) > 0){
        streak++;
        d.setDate(d.getDate()-1);
      }else{
        break;
      }
    }
    return streak;
  }

  let __dailySaveTimer = null;
  function dailyInc(kind, n=1){
    if(!DAILY || DAILY.date !== jstDateKey()) loadDailyForCurrent();
    if(kind === "seen") DAILY.seen += n;
    if(kind === "correct") DAILY.correct += n;
    if(kind === "wrong") DAILY.wrong += n;
    if(kind === "skip") DAILY.skip += n;

    try{ if(__dailySaveTimer) clearTimeout(__dailySaveTimer); }catch(e){}
    __dailySaveTimer = setTimeout(()=>{
      saveDaily();
      upsertTodayInHistory();
      renderDailyUI();
    }, 80);
  }

  function renderDailyUI(){
    const acc = DAILY.seen ? Math.round((DAILY.correct/DAILY.seen)*100) : 0;
    const streak = calcStreak();

    const elDailyHud = document.getElementById("dailyHud");
    const elStreakHud = document.getElementById("streakHud");
    const elDailySummaryLine = document.getElementById("dailySummaryLine");
    const elStreakLine = document.getElementById("streakLine");
    const elDailyHistory = document.getElementById("dailyHistory");

    if(elDailyHud) elDailyHud.textContent = `${DAILY.seen}å• ${acc}%`;
    if(elStreakHud) elStreakHud.textContent = `ğŸ”¥${streak}`;

    if(elDailySummaryLine){
      elDailySummaryLine.textContent = `ä»Šæ—¥: å‡ºé¡Œ${DAILY.seen} / æ­£è§£${DAILY.correct} / ä¸æ­£è§£${DAILY.wrong} / ã‚¹ã‚­ãƒƒãƒ—${DAILY.skip} / æ­£è§£ç‡${acc}%`;
    }
    if(elStreakLine){
      elStreakLine.textContent = `é€£ç¶š: ${streak}æ—¥`;
    }

    if(elDailyHistory){
      const arr = loadDailyHistory();
      if(!arr.length){
        elDailyHistory.innerHTML = `<div class="small">ã¾ã å±¥æ­´ãŒãªã„ã‚ˆã€‚ã¾ãšã¯ä½•å•ã‹è§£ã„ã¦ã­ã€‚</div>`;
      }else{
        elDailyHistory.innerHTML = arr.map(r=>{
          const seen = Number(r.seen||0);
          const correct = Number(r.correct||0);
          const a = seen ? Math.round((correct/seen)*100) : 0;
          return `<div style="padding:6px 0;border-bottom:1px solid rgba(255,255,255,.08);">
            <b>${escapeHtml(r.date || "")}</b> <span class="small">(${escapeHtml(r.csvName||"")})</span><br/>
            <span class="small">å‡ºé¡Œ${seen} / æ­£è§£ç‡${a}%ï¼ˆæ­£è§£${correct}ãƒ»ä¸æ­£è§£${Number(r.wrong||0)}ãƒ»ã‚¹ã‚­ãƒƒãƒ—${Number(r.skip||0)}ï¼‰</span>
          </div>`;
        }).join("");
      }
    }
  }


  
  // =========================
  // DOM
  // =========================
  const elScore = document.getElementById("score");
  const elCombo = document.getElementById("combo");
  const elAcc = document.getElementById("acc");
  const elRemaining = document.getElementById("remaining");
  const elCsvHud = document.getElementById("csvHud");
  const elPrompt = document.getElementById("prompt");
  const elTime = document.getElementById("time");
  const elBar = document.getElementById("bar");
  const elChoices = document.getElementById("choices");
  const elFlash = document.getElementById("flash");
  const elModeLabel = document.getElementById("modeLabel");

  const elSkip = document.getElementById("skip");
  const elRestart = document.getElementById("restart");
  const elShowResultsBtn = document.getElementById("showResultsBtn");
  const elPauseBtn = document.getElementById("pauseBtn");

const elDirection = document.getElementById("direction");
  const elSecondsPerQ = document.getElementById("secondsPerQ");
  const elReviewWeight = document.getElementById("reviewWeight");
  const elRounds = document.getElementById("rounds");

  const elDeckSelect = document.getElementById("deckSelect");
  const elDeckStatus = document.getElementById("deckStatus");

  const elCsvFile = document.getElementById("csvFile");
  const elCsvStatus = document.getElementById("csvStatus");

  // CSV overwrite choice panel
  const elOverwritePanel = document.getElementById("overwritePanel");
  const elOverwriteInfo  = document.getElementById("overwriteInfo");
  const elBtnInheritAll  = document.getElementById("btnInheritAll");
  const elBtnMergeCommon = document.getElementById("btnMergeCommon");
  const elBtnResetNew    = document.getElementById("btnResetNew");
  const elBtnCancelLoad  = document.getElementById("btnCancelLoad");

  const elReviewMode = document.getElementById("reviewMode");
  const elReviewCount = document.getElementById("reviewCount");
  const elPickReview = document.getElementById("pickReview");
  const elClearReview = document.getElementById("clearReview");


  const elResetStats = document.getElementById("resetStats");
const elAutoPickWeak = document.getElementById("autoPickWeak");
const elWeakThreshold = document.getElementById("weakThreshold");

const elAutoPickWeakGlobal = document.getElementById("autoPickWeakGlobal");
const elOpenGlobalWeak = document.getElementById("openGlobalWeak");

const elGlobalWeakPanel = document.getElementById("globalWeakPanel");
const elCloseGlobalWeak = document.getElementById("closeGlobalWeak");
const elRefreshGlobalWeak = document.getElementById("refreshGlobalWeak");
const elApplyGlobalWeakToReview = document.getElementById("applyGlobalWeakToReview");
const elLoadGlobalReview = document.getElementById("loadGlobalReview");
const elGlobalWeakList = document.getElementById("globalWeakList");
const elGlobalWeakInfo = document.getElementById("globalWeakInfo");
const elGlobalMinSeen = document.getElementById("globalMinSeen");
const elGlobalWeakThreshold = document.getElementById("globalWeakThreshold");



  const elReviewStatus = document.getElementById("reviewStatus");
  const elReviewPanel = document.getElementById("reviewPanel");
  const elReviewList = document.getElementById("reviewList");
  const elSaveReview = document.getElementById("saveReview");
  const elReviewMax = document.getElementById("reviewMax");

  const elResultPanel = document.getElementById("resultPanel");
  const elResultMinSeen = document.getElementById("resultMinSeen");
  const elAutoPickWeakFromResults = document.getElementById("autoPickWeakFromResults");
  const elResultSummary = document.getElementById("resultSummary");
  const elResultTable = document.getElementById("resultTable");
  const elCloseResult = document.getElementById("closeResult");

    const elCloseResultTop = document.getElementById("closeResultTop");
// çµæœè¡¨ç¤ºãƒ•ã‚£ãƒ«ã‚¿ãƒ¼
  elResultMinSeen?.addEventListener("change", () => {
    // ã™ã§ã«çµæœãƒ‘ãƒãƒ«ãŒé–‹ã„ã¦ã„ã‚‹ã¨ãã¯å³åæ˜ 
    if (elResultPanel && elResultPanel.style.display !== "none") showResults();
  });

  // TTS
  const elSpeak = document.getElementById("speak");
  const elStopSpeak = document.getElementById("stopSpeak");
  const elAutoSpeak = document.getElementById("autoSpeak");
  const elVoiceSelect = document.getElementById("voiceSelect");
  const elRate = document.getElementById("rate");
  const elRateLabel = document.getElementById("rateLabel");
  const elVolume = document.getElementById("volume");
  const elVolLabel = document.getElementById("volLabel");
  const elTtsHint = document.getElementById("ttsHint");

  const elVoiceMode = document.getElementById("voiceMode");
  let VOICE_MODE = localStorage.getItem("VOICE_MODE") || "auto"; // auto | local | online

  if (elVoiceMode) {
    elVoiceMode.value = VOICE_MODE;
    elVoiceMode.addEventListener("change", () => {
      VOICE_MODE = elVoiceMode.value;
      localStorage.setItem("VOICE_MODE", VOICE_MODE);
      showFlash("good", "éŸ³å£°ãƒ¢ãƒ¼ãƒ‰: " + (VOICE_MODE === "auto" ? "è‡ªå‹•" : (VOICE_MODE === "local" ? "ãƒ­ãƒ¼ã‚«ãƒ«ã®ã¿" : "ã‚ªãƒ³ãƒ©ã‚¤ãƒ³ã®ã¿")));
    });
  }

  // ã‚ªãƒ³ãƒ©ã‚¤ãƒ³èª­ã¿ä¸Šã’ï¼ˆç°¡æ˜“TTSï¼‰: è¨€èªã‚³ãƒ¼ãƒ‰ã¯ primaryï¼ˆä¾‹: fr, it, jaï¼‰
  // æ³¨æ„: ã‚µãƒ¼ãƒ“ã‚¹å´ã®åˆ¶é™ã§å‹•ã‹ãªã„å ´åˆãŒã‚ã‚Šã¾ã™ã€‚ãã®æ™‚ã¯ãƒ­ãƒ¼ã‚«ãƒ«/è‡ªå‹•ã«æˆ»ã—ã¦ãã ã•ã„ã€‚
  let __onlineAudio = null;
  function speakOnline(text, langPrimary, isAuto=false){
    try{
      const lp = String(langPrimary || "en").toLowerCase();
      // translate_tts ã¯çŸ­æ–‡å‘ã‘ã€‚é•·æ–‡ã¯é€”åˆ‡ã‚Œã‚‹ã“ã¨ãŒã‚ã‚Šã¾ã™ã€‚
      const url = `https://translate.google.com/translate_tts?ie=UTF-8&q=${encodeURIComponent(text)}&tl=${lp}&client=tw-ob`;
      if (!__onlineAudio) __onlineAudio = new Audio();
      if (!isAuto) { try{ __onlineAudio.pause(); }catch(e){} }
      __onlineAudio.src = url;
      __onlineAudio.play().catch(()=>{ /* blocked */ });
      if (elTtsHint) elTtsHint.textContent = `ç¾åœ¨ã®éŸ³å£°: Online TTS / ${lp}`;
    }catch(e){}
  }


  // =========================
  // æˆç¸¾ï¼ˆå˜èªã”ã¨ï¼‰
  // =========================
  let STATS = new Map();
  function wordKey(w){ return `${w.en}||${w.ja}||${w.level}`; }
  function ensureStat(w){
    const k = wordKey(w);
    if (!STATS.has(k)) {
      STATS.set(k, {
        en: w.en, ja: w.ja, level: w.level,
        seen: 0, correct: 0, wrong: 0, skip: 0,
        wrongChoices: new Set(),
        langs: new Set(),
      });
    }
    const st = STATS.get(k);
    try { const l = normLang(w.lang || w.en_lang || ''); if (l) st.langs.add(l); } catch {}
    return st;
  }

  
  // =========================
  // Language filter (lang column)
  // =========================
  const elLangFilter = document.getElementById("langFilter");
  const elLangChips = document.getElementById("langChips");
  const elLangAll = document.getElementById("langAll");
  const elLangClear = document.getElementById("langClear");
  const elLangFilterStatus = document.getElementById("langFilterStatus");

  let SELECTED_LANGS = new Set(); // empty = all (no filter)

  function normLang(x){
    const s = (x || "").toString().trim();
    if (!s) return "";
    const t = s.replace("_","-");
    const low = t.toLowerCase();
    // tolerant mapping (CSV may use short tags)
    if (low === "en") return "en-US";
    if (low === "ja") return "ja-JP";
    if (low === "ko") return "ko-KR";
    if (low === "zh-tw" || low === "zh-hant" || low === "tw") return "zh-TW";
    if (low === "zh-cn" || low === "zh-hans" || low === "cn") return "zh-CN";
    if (low === "fr") return "fr-FR";
    if (low === "de") return "de-DE";
    if (low === "es") return "es-ES";
    if (low === "it") return "it-IT";
    if (low === "pt" || low === "pt-br") return "pt-BR";
    // normalize casing like en-us -> en-US
    const parts = t.split("-");
    if (parts.length === 1) return parts[0];
    return parts[0].toLowerCase() + "-" + parts[1].toUpperCase();
  }

  function getKnownLangs() {
    const s = new Set();
    // current words
    try { (WORDS || []).forEach(w => { const l = normLang(w.lang || w.en_lang); if (l) s.add(l); }); } catch {}
    // review set
    try { (REVIEW_SET || []).forEach(w => { const l = normLang(w.lang || w.en_lang); if (l) s.add(l); }); } catch {}
    // stats (across this CSV) if langs stored
    try {
      (STATS || new Map()).forEach(v => {
        if (v && v.langs) for (const l of v.langs) if (l) s.add(l);
      });
    } catch {}
    // nice defaults
    if (s.size === 0) { ["en-US","ja-JP","ko-KR","zh-TW","zh-CN","fr-FR","de-DE","es-ES","it-IT","pt-BR"].forEach(x=>s.add(x)); }
    return Array.from(s).sort();
  }

  
  function renderLangFilterOptions() {
    const langs = getKnownLangs();
    const prev = new Set(Array.from(SELECTED_LANGS));

    // hidden select (for compatibility / debugging)
    if (elLangFilter) {
      elLangFilter.innerHTML = "";
      for (const l of langs) {
        const opt = document.createElement("option");
        opt.value = l;
        opt.textContent = l;
        elLangFilter.appendChild(opt);
      }
    }

    // chips UI (mobile-friendly)
    if (elLangChips) {
      elLangChips.innerHTML = "";
      for (const l of langs) {
        const b = document.createElement("button");
        b.type = "button";
        b.className = "langchip";
        b.textContent = l;

        const isOn = prev.has(l);
        if (isOn) b.classList.add("on");

        b.addEventListener("click", () => {
          // Toggle selection
          if (SELECTED_LANGS.size === 0) {
            // ç›´å‰ãŒã€Œå…¨è§£é™¤(ãƒ•ã‚£ãƒ«ã‚¿ãƒ¼ç„¡ã—)ã€= ç©ºã‚»ãƒƒãƒˆã®å ´åˆ
            // æœ€åˆã®1ã‚¯ãƒªãƒƒã‚¯ã¯ã€Œãã®è¨€èªã ã‘é¸ã¶ï¼ˆå˜ç‹¬é¸æŠï¼‰ã€ã«ã™ã‚‹
            SELECTED_LANGS = new Set([l]);
          } else {
            // é€šå¸¸ãƒˆã‚°ãƒ«
            if (SELECTED_LANGS.has(l)) SELECTED_LANGS.delete(l);
            else SELECTED_LANGS.add(l);

            // ã‚‚ã—å…¨éƒ¨ONã«ãªã£ãŸã‚‰ã€Œãƒ•ã‚£ãƒ«ã‚¿ãƒ¼ç„¡ã—ï¼ˆå…¨éƒ¨å¯¾è±¡ï¼‰ã€ã«ç•³ã‚€
            if (SELECTED_LANGS.size === langs.length) {
              SELECTED_LANGS = new Set(); // all
            }
          }

          // Re-render chips + status
          renderLangFilterOptions();
          updateLangFilterStatus();
        });

        elLangChips.appendChild(b);
      }
    }

    updateLangFilterStatus();
  }


  function updateSelectedLangsFromUI() {
    // ãƒãƒƒãƒ—UIã‚’ä½¿ã†ã®ã§ã€selectå¤‰æ›´ã¯åŸºæœ¬ä½¿ã‚ãªã„ï¼ˆäº’æ›ç”¨ï¼‰
    if (!elLangFilter) return;
    const selected = Array.from(elLangFilter.selectedOptions).map(o => o.value);
    const all = Array.from(elLangFilter.options).map(o => o.value);
    // If everything selected => treat as "all" (empty set) to keep simple
    if (selected.length === 0 || selected.length === all.length) {
      SELECTED_LANGS = new Set(); // all
    } else {
      SELECTED_LANGS = new Set(selected);
    }
    updateLangFilterStatus();
  }

  function updateLangFilterStatus() {
    if (!elLangFilterStatus) return;
    if (SELECTED_LANGS.size === 0) {
      elLangFilterStatus.textContent = "è¨€èª: ã™ã¹ã¦";
    } else {
      elLangFilterStatus.textContent = "è¨€èª: " + Array.from(SELECTED_LANGS).join(", ");
    }
  }

  function langPass(w) {
    const l = normLang(w?.lang || w?.en_lang);
    if (SELECTED_LANGS.size === 0) return true; // all
    return SELECTED_LANGS.has(l);
  }

  function filterByLang(list) {
    const arr = Array.isArray(list) ? list : [];
    // é¸æŠãŒç©ºï¼ˆ=ãƒ•ã‚£ãƒ«ã‚¿ãƒ¼ç„¡ã—ï¼‰ã®ã¨ãã¯ã€ãã®ã¾ã¾å…¨éƒ¨OK
    if (SELECTED_LANGS.size === 0) return arr;
    // ãã‚Œä»¥å¤–ã¯å³å¯†ã«ãƒ•ã‚£ãƒ«ã‚¿ãƒ¼ã™ã‚‹ï¼ˆ0ä»¶ãªã‚‰0ä»¶ã§è¿”ã™ï¼‰
    return arr.filter(w => langPass(w));
  }


  function debugActiveStatus(activeList){
    try{
      const deckv = elDeckSelect ? elDeckSelect.value : "all";
      const langtxt = (SELECTED_LANGS.size === 0) ? "ã™ã¹ã¦" : Array.from(SELECTED_LANGS).join(", ");
      const rev = elReviewMode ? elReviewMode.value : "off";
      const revn = (REVIEW_SET && REVIEW_SET.length) ? REVIEW_SET.length : 0;
      if (elCsvStatus){
        elCsvStatus.textContent =
          `ç¾åœ¨ã®CSV: ${CURRENT_CSV_NAME}ï¼ˆç·${(WORDS_ALL||[]).length}èªï¼‰ / æœ‰åŠ¹:${(activeList||[]).length}èª / ãƒ‡ãƒƒã‚­:${deckv} / è¨€èª:${langtxt} / å¾©ç¿’:${rev}(${revn})`;
      }
    }catch(e){}
  }


  // =========================
  // State
  // =========================
  let deck = [];
  let current = null;
  let locked = false;

  let isPaused = false;


// ===== Auto Pause on Tab Hidden (prevents ranking drift while left open) =====
let __lastHiddenAt = 0;
document.addEventListener("visibilitychange", () => {
  if (document.hidden) {
    __lastHiddenAt = Date.now();
    // stop timer/game progress
    isPaused = true;
    try { showFlash("bad", "â¸ ç”»é¢ãŒéè¡¨ç¤ºã®ãŸã‚è‡ªå‹•åœæ­¢ä¸­"); } catch(e) {}
  
    try{ if (elPauseBtn) elPauseBtn.textContent = "â–¶ å†é–‹"; }catch(e){}
} else {
    // Do NOT auto-resume to avoid accidental progress.
    // User can resume via the existing pause/resume control.
    try { showFlash("good", "â–¶ æˆ»ã‚Šã¾ã—ãŸã€‚å†é–‹ã™ã‚‹ã«ã¯ã€Œâ–¶ å†é–‹ã€ã‚’æŠ¼ã—ã¦ã­"); } catch(e) {}
  }
});

// ===== Idle Auto Pause (even while visible) =====
// If no user input for this long, the game pauses to prevent ranking drift while left open.
// Change the number to your liking (milliseconds). Example: 300000 = 5 minutes.
let IDLE_LIMIT_MS = 30000; // 30ç§’
let __lastActiveAt = Date.now();
let __idlePaused = false;

function __markActive(){
  __lastActiveAt = Date.now();
  // If it was paused by idle, resume on next user action
  if(__idlePaused){
    __idlePaused = false;
    // resume only if user is actually back
    isPaused = false;
    try {
      if (typeof scheduleTimer === "function") scheduleTimer(pausedRemain ?? secondsPerQ);
      try { showFlash("good", "â–¶ æ“ä½œã‚’æ¤œçŸ¥ã—ãŸã®ã§å†é–‹ã—ãŸã‚ˆ"); } catch(e) {}
    } catch(e) {}
  }
}

["mousemove","mousedown","keydown","touchstart","pointerdown","wheel","click"].forEach(ev=>{
  window.addEventListener(ev, __markActive, {passive:true});
});

setInterval(()=>{
  try{
    if (document.hidden) return;         // handled by visibility pause
    if (__idlePaused) return;
    if (isPaused) return;               // already paused by user/overlay
    const idleMs = Date.now() - __lastActiveAt;
    if (idleMs >= IDLE_LIMIT_MS){
      isPaused = true;
      __idlePaused = true;
      
      try{ if (elPauseBtn) elPauseBtn.textContent = "â–¶ å†é–‹"; }catch(e){}
const sec = Math.round(IDLE_LIMIT_MS/1000);
      try { showFlash("bad", `â¸ ${sec}ç§’æ“ä½œãŒãªã„ã®ã§è‡ªå‹•åœæ­¢ï¼ˆã‚¯ãƒªãƒƒã‚¯/ã‚­ãƒ¼ã§å†é–‹ï¼‰`); } catch(e) {}
    }
  }catch(e){}
}, 1000);

  let pausedRemain = null;

  // =========================
  // Overlay pause control
  // ç”»é¢ã«ã€Œãƒ©ãƒ³ã‚­ãƒ³ã‚°/è‹¦æ‰‹ã‚»ãƒƒãƒˆã€ãªã©ã®ãƒ‘ãƒãƒ«ã‚’å‡ºã—ã¦ã„ã‚‹é–“ã«
  // ã‚¿ã‚¤ãƒãƒ¼ãŒè£ã§é€²ã‚“ã§å‹æ‰‹ã«å•é¡ŒãŒé€²ã‚€ã®ã‚’é˜²ã
  // =========================
  let overlayDepth = 0;
  let wasRunningBeforeOverlay = false;
  let overlayRequireManualResume = false;
  let needsResetAfterOverlayAction = false; // ãƒ‘ãƒãƒ«å†…æ“ä½œå¾Œã€æ‰‹å‹•å†é–‹æ™‚ã«resetGameã™ã‚‹
  function openOverlay(panelEl){
    if (!panelEl) return;
    if (overlayDepth === 0){
      wasRunningBeforeOverlay = !isPaused;
      overlayRequireManualResume = false;
    }
    overlayDepth++;
    // ä¸€æ™‚åœæ­¢ï¼ˆã‚¿ã‚¤ãƒãƒ¼tickã¯ isPaused ã‚’è¦‹ã¦æ­¢ã¾ã‚‹ï¼‰
    isPaused = true;
    
    try{ if (elPauseBtn) elPauseBtn.textContent = "â–¶ å†é–‹"; }catch(e){}
panelEl.style.display = "block";
  }

  function closeOverlay(panelEl){
    if (!panelEl) return;
    panelEl.style.display = "none";
    overlayDepth = Math.max(0, overlayDepth - 1);
    // ãƒ‘ãƒãƒ«ã‚’å…¨éƒ¨é–‰ã˜ãŸã‚‰ã€é–‹ãå‰ã«å‹•ã„ã¦ã„ãŸæ™‚ã ã‘å†é–‹
    if (overlayDepth === 0 && wasRunningBeforeOverlay && !overlayRequireManualResume){
      isPaused = false;
      scheduleTimer(pausedRemain ?? secondsPerQ);
    
      try{ if (elPauseBtn) elPauseBtn.textContent = "â¸ ä¸€æ™‚åœæ­¢"; }catch(e){}
} else if (overlayDepth === 0) {
      // ãƒ‘ãƒãƒ«å†…ã§ã‚»ãƒƒãƒˆæ“ä½œãªã©ã‚’ã—ãŸå ´åˆã¯ã€é–‰ã˜ã¦ã‚‚è‡ªå‹•å†é–‹ã—ãªã„
      // å†é–‹ã¯ãƒ¦ãƒ¼ã‚¶ãƒ¼ãŒã€Œçµæœã‚’è¦‹ã‚‹ã€ãƒœã‚¿ãƒ³ã§è¡Œã†
      wasRunningBeforeOverlay = false;
    }
  }

  let score = 0;
  let combo = 0;
  let correct = 0;
  let answered = 0;

  let secondsPerQ = 6;
  let reviewWeight = 5;

  let rafId = null;

  // å‘¨å›
  let roundsMode = 1;     // 1..10 or Infinity
  let totalPlanned = 0;   // æœ‰é™: ç·å•é¡Œæ•° / Infinity
  let askedCount = 0;     // å‡ºé¡Œæ•°

  // å¾©ç¿’ã‚»ãƒƒãƒˆ
  let REVIEW_SET = [];

  // â‘¢ æ–¹å‘
  function getDirection(){ return elDirection?.value || "ja2en"; } // ja2en | en2ja

  // =========================
  // Utils
  // =========================
  function shuffle(arr) {
    const a = arr.slice();
    for (let i = a.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [a[i], a[j]] = [a[j], a[i]];
    }
    return a;
  }
  function clamp(n, min, max) { return Math.max(min, Math.min(max, n)); }
  function pickN(arr, n, avoidValue) {
    const pool = arr.filter(x => x !== avoidValue);
    return shuffle(pool).slice(0, n);
  }
  function escapeHtml(s){
    return String(s).replace(/[&<>"']/g, (c)=>({
      "&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#39;"
    }[c]));
  }

  // =========================
  // Review persistence (per CSV hash)
  // =========================
  function normalizeCsvText(text) {
  // CSVå†…å®¹ã®æŒ‡ç´‹ï¼ˆãƒãƒƒã‚·ãƒ¥ï¼‰ã‚’å®‰å®šã•ã›ã‚‹ãŸã‚ã®æ­£è¦åŒ–
  // - æ”¹è¡Œã‚³ãƒ¼ãƒ‰å·®ï¼ˆCRLF/LF/CRï¼‰ã‚’çµ±ä¸€
  // - æœ«å°¾ã®ç©ºç™½ã‚„ä½™åˆ†ãªç©ºè¡Œã®æºã‚Œã‚’å¸å
  return (text || "")
    .replace(/\r\n/g, "\n")
    .replace(/\r/g, "\n")
    .trim();
}

async function sha256Hex(text) {
    const enc = new TextEncoder();
    const buf = enc.encode(text);
    const digest = await crypto.subtle.digest("SHA-256", buf);
    const bytes = Array.from(new Uint8Array(digest));
    return bytes.map(b => b.toString(16).padStart(2, "0")).join("");
  }

  function reviewStorageKeyFor(hash){ return `hamaru_review_set::${hash || "builtin"}`; }
function reviewStorageKey(){ return reviewStorageKeyFor(CURRENT_CSV_HASH); }

  function saveReviewToStorage() {
    try {
      const data = (REVIEW_SET || []).map(w => ({
        en: w.en, ja: w.ja, level: Number(w.level ?? 1),
        en_lang: w.en_lang || "", ja_lang: w.ja_lang || ""
      }));
      localStorage.setItem(reviewStorageKey(), JSON.stringify(data));
    } catch {}
  }

  function loadReviewFromStorage() {
    try {
      const raw = localStorage.getItem(reviewStorageKey());
      if (!raw) return;
      const arr = JSON.parse(raw);
      if (!Array.isArray(arr)) return;
      REVIEW_SET = arr;
    } catch {}
  }

  function clearReviewFromStorage() {
    try { localStorage.removeItem(reviewStorageKey()); } catch {}
  }


  // =========================
  // Stats persistence (per CSV hash)
  // =========================
  const STATS_PREFIX = "hamaru_stats::";
  function statsStorageKeyFor(hash){ return `${STATS_PREFIX}${hash || "builtin"}`; }
  function statsStorageKey(){ return statsStorageKeyFor(CURRENT_CSV_HASH); }

  function serializeStatsMap(map){
    const out = [];
    map.forEach((v) => {
      out.push({
        en: v.en, ja: v.ja, level: Number(v.level ?? 1),
        seen: Number(v.seen||0), correct: Number(v.correct||0), wrong: Number(v.wrong||0), skip: Number(v.skip||0),
        wrongChoices: Array.from(v.wrongChoices || []),
        langs: Array.from(v.langs || [])
      });
    });
    return out;
  }

  function loadStatsFromStorage(hash = CURRENT_CSV_HASH){
    try {
      const raw = localStorage.getItem(statsStorageKeyFor(hash));
      if (!raw) { STATS = new Map(); return; }
      const arr = JSON.parse(raw);
      if (!Array.isArray(arr)) { STATS = new Map(); return; }
      STATS = new Map();
      for (const r of arr) {
        const w = { en: r.en, ja: r.ja, level: Number(r.level ?? 1) };
        const st = ensureStat(w);
        st.seen = Number(r.seen||0);
        st.correct = Number(r.correct||0);
        st.wrong = Number(r.wrong||0);
        st.skip = Number(r.skip||0);
        st.wrongChoices = new Set(Array.isArray(r.wrongChoices) ? r.wrongChoices : []);
        st.langs = new Set(Array.isArray(r.langs) ? r.langs : []);
      }
    } catch {
      STATS = new Map();
    }
  }

  let _statsSaveTimer = null;
  function scheduleSaveStats(){
    try { if (_statsSaveTimer) clearTimeout(_statsSaveTimer); } catch {}
    _statsSaveTimer = setTimeout(() => {
      try {
        const data = serializeStatsMap(STATS);
        localStorage.setItem(statsStorageKey(), JSON.stringify(data));
      } catch {}
    }, 250);
  }

  // =========================
  // CSV index (filename -> hashes) for overwrite detection
  // =========================
  const CSV_INDEX_KEY = "hamaru_csv_index_v1";
  function loadCsvIndex(){
    try {
      const raw = localStorage.getItem(CSV_INDEX_KEY);
      const obj = raw ? JSON.parse(raw) : null;
      if (obj && typeof obj === "object") return obj;
    } catch {}
    return { files: {} };
  }
  function saveCsvIndex(idx){
    try { localStorage.setItem(CSV_INDEX_KEY, JSON.stringify(idx)); } catch {}
  }
  function getLastHashForFilename(filename){
    const idx = loadCsvIndex();
    const rec = idx.files?.[filename];
    return rec?.lastHash || "";
  }
  function recordFilenameHash(filename, hash, wordCount){
    const idx = loadCsvIndex();
    if (!idx.files) idx.files = {};
    if (!idx.files[filename]) idx.files[filename] = { lastHash:"", entries:[] };
    const rec = idx.files[filename];
    rec.lastHash = hash;
    const now = Date.now();
    // keep unique
    rec.entries = (rec.entries || []).filter(e => e.hash !== hash);
    rec.entries.unshift({ hash, savedAt: now, wordCount: Number(wordCount||0) });
    // trim
    rec.entries = rec.entries.slice(0, 20);
    saveCsvIndex(idx);
  }

  function reviewDataForHash(hash){
    try {
      const raw = localStorage.getItem(reviewStorageKeyFor(hash));
      const arr = raw ? JSON.parse(raw) : [];
      return Array.isArray(arr) ? arr : [];
    } catch { return []; }
  }
  function statsDataForHash(hash){
    try {
      const raw = localStorage.getItem(statsStorageKeyFor(hash));
      const arr = raw ? JSON.parse(raw) : [];
      return Array.isArray(arr) ? arr : [];
    } catch { return []; }
  }
  function writeReviewDataForHash(hash, arr){
    try { localStorage.setItem(reviewStorageKeyFor(hash), JSON.stringify(arr || [])); } catch {}
  }
  function writeStatsDataForHash(hash, arr){
    try { localStorage.setItem(statsStorageKeyFor(hash), JSON.stringify(arr || [])); } catch {}
  }

  function mergeStatsCommon(oldStatsArr, newWords){
    const allowed = new Set(newWords.map(w => wordKey(w)));
    return (oldStatsArr || []).filter(r => {
      const k = `${r.en}||${r.ja}||${Number(r.level ?? 1)}`;
      return allowed.has(k);
    });
  }
  function mergeReviewCommon(oldReviewArr, newWords){
    const allowed = new Set(newWords.map(w => wordKey(w)));
    return (oldReviewArr || []).filter(r => {
      const k = `${r.en}||${r.ja}||${Number(r.level ?? 1)}`;
      return allowed.has(k);
    });
  }

  // =========================
  // Global weak ranking (across all CSV hashes)
  // =========================
  const GLOBAL_REVIEW_KEY = "hamaru_review_set::GLOBAL";

  function saveGlobalReview(arr){
    try { localStorage.setItem(GLOBAL_REVIEW_KEY, JSON.stringify(arr || [])); } catch {}
  }
  function loadGlobalReviewFromStorage(){
    try {
      const raw = localStorage.getItem(GLOBAL_REVIEW_KEY);
      const arr = raw ? JSON.parse(raw) : [];
      return Array.isArray(arr) ? arr : [];
    } catch { return []; }
  }

  function listAllStatsHashes(){
    const hashes = [];
    try {
      for (let i=0; i<localStorage.length; i++){
        const k = localStorage.key(i);
        if (k && k.startsWith(STATS_PREFIX)){
          hashes.push(k.slice(STATS_PREFIX.length));
        }
      }
    } catch {}
    hashes.sort();
    return hashes;
  }

  function buildHashToFilenameMap(){
    const idx = loadCsvIndex();
    const map = new Map(); // hash -> filename (latest-ish)
    try {
      const files = idx?.files || {};
      for (const filename of Object.keys(files)){
        const rec = files[filename];
        const entries = rec?.entries || [];
        for (const e of entries){
          if (e && e.hash && !map.has(e.hash)) map.set(e.hash, filename);
        }
        if (rec?.lastHash && !map.has(rec.lastHash)) map.set(rec.lastHash, filename);
      }
    } catch {}
    return map;
  }

  function wordKeyFromRow(r){
    return `${r.en}||${r.ja}||${Number(r.level ?? 1)}`;
  }

  function computeGlobalWeakRanking(minSeen, threshold01){
    const hashToFile = buildHashToFilenameMap();
    const hashes = listAllStatsHashes();

    // key -> aggregate
    const agg = new Map();
    for (const h of hashes){
      const arr = statsDataForHash(h);
      const srcName = hashToFile.get(h) || `hash:${h.slice(0,8)}`;
      for (const r of (arr || [])){
        const k = wordKeyFromRow(r);
        const seen = Number(r.seen||0);
        const correct = Number(r.correct||0);
        const wrong = Number(r.wrong||0);
        const skip = Number(r.skip||0);
        if (!agg.has(k)){
          agg.set(k, {
            en: r.en, ja: r.ja, level: Number(r.level ?? 1),
            seen: 0, correct: 0, wrong: 0, skip: 0,
            sources: [] // {hash, filename, seen, correct, wrong, acc}
          });
        }
        const a = agg.get(k);
        a.seen += seen; a.correct += correct; a.wrong += wrong; a.skip += skip;
        if (seen > 0){
          a.sources.push({
            hash: h,
            filename: srcName,
            seen, correct, wrong,
            acc: seen ? (correct/seen) : 1
          });
        }
      }
    }

    const list = Array.from(agg.values())
      .map(a => ({...a, acc: a.seen ? (a.correct/a.seen) : 1}))
      .filter(a => a.seen >= minSeen)
      .filter(a => a.acc < threshold01)
      .sort((x, y) => {
        // lower accuracy first
        if (x.acc !== y.acc) return x.acc - y.acc;
        // more evidence first
        if (x.seen !== y.seen) return y.seen - x.seen;
        // then more wrong
        return y.wrong - x.wrong;
      });

    return { list, hashesCount: hashes.length };
  }

  function renderGlobalWeak(){
    if (!elGlobalWeakList) return;

    const minSeen = clamp(parseInt(elGlobalMinSeen?.value || "5", 10), 1, 9999);
    const th01 = clamp(parseInt(elGlobalWeakThreshold?.value || "30", 10), 0, 100) / 100;

    const { list, hashesCount } = computeGlobalWeakRanking(minSeen, th01);

    if (elGlobalWeakInfo){
      elGlobalWeakInfo.textContent = `ä¿å­˜ã•ã‚ŒãŸæˆç¸¾ã‚»ãƒƒãƒˆ: ${hashesCount}ä»¶ / æ¡ä»¶ã«å½“ã¦ã¯ã¾ã‚‹è‹¦æ‰‹å˜èª: ${list.length}èª`;
    }

    if (list.length === 0){
      elGlobalWeakList.innerHTML = `<div class="small">ã¾ã è‹¦æ‰‹ãƒ‡ãƒ¼ã‚¿ãŒãªã„ã‹ã€æ¡ä»¶ãŒå³ã—ã™ãã‚‹ã‹ã‚‚ã€‚<br/>ã¾ãšä½•å•ã‹è§£ã„ã¦ã‹ã‚‰ã€Œæ›´æ–°ã€ã—ã¦ã­ã€‚</div>`;
      return;
    }

    // show top 200
    const top = list.slice(0, 200);

    let html = `
<table style="width:100%;border-collapse:collapse;">
  <thead>
    <tr>
      <th style="text-align:left;padding:6px;border-bottom:1px solid rgba(255,255,255,.12);">å˜èª</th>
      <th style="text-align:right;padding:6px;border-bottom:1px solid rgba(255,255,255,.12);">æ­£è§£ç‡</th>
      <th style="text-align:right;padding:6px;border-bottom:1px solid rgba(255,255,255,.12);">å‡ºé¡Œ</th>
      <th style="text-align:right;padding:6px;border-bottom:1px solid rgba(255,255,255,.12);">ä¸æ­£è§£</th>
      <th style="text-align:left;padding:6px;border-bottom:1px solid rgba(255,255,255,.12);">ç”±æ¥ï¼ˆCSVã”ã¨ï¼‰</th>
    </tr>
  </thead>
  <tbody>
`;
    for (const a of top){
      const accPct = a.seen ? Math.round((a.correct/a.seen)*100) : 0;

      // sources: show worst 3 by acc, then by seen desc
      const src = (a.sources || []).slice().sort((u,v)=>{
        if (u.acc !== v.acc) return u.acc - v.acc;
        return (v.seen||0) - (u.seen||0);
      }).slice(0, 3).map(s=>{
        const p = s.seen ? Math.round((s.correct/s.seen)*100) : 0;
        return `${escapeHtml(s.filename)} ${p}%ï¼ˆ${s.seen}ï¼‰`;
      }).join("<br/>");

      html += `
    <tr>
      <td style="padding:6px;border-bottom:1px solid rgba(255,255,255,.06);">
        <b>${escapeHtml(a.ja)}</b>
        <span class="small">â†” ${escapeHtml(a.en)}ï¼ˆLv${a.level}ï¼‰</span>
      </td>
      <td style="padding:6px;text-align:right;border-bottom:1px solid rgba(255,255,255,.06);">${accPct}%</td>
      <td style="padding:6px;text-align:right;border-bottom:1px solid rgba(255,255,255,.06);">${a.seen}</td>
      <td style="padding:6px;text-align:right;border-bottom:1px solid rgba(255,255,255,.06);">${a.wrong}</td>
      <td style="padding:6px;border-bottom:1px solid rgba(255,255,255,.06);"><span class="small">${src || ""}</span></td>
    </tr>
`;
    }
    html += `</tbody></table>`;
    elGlobalWeakList.innerHTML = html;
  }

  function applyGlobalWeakToReview(){
    const max = clamp(parseInt(elReviewCount?.value || "10", 10), 4, 50);
    const minSeen = clamp(parseInt(elGlobalMinSeen?.value || "5", 10), 1, 9999);
    const th01 = clamp(parseInt(elGlobalWeakThreshold?.value || "30", 10), 0, 100) / 100;

    const { list } = computeGlobalWeakRanking(minSeen, th01);
    const picked = list.slice(0, max).map(a => ({ en:a.en, ja:a.ja, level:a.level }));

    if (picked.length < 4){
      showFlash("bad", "4æŠãªã®ã§ã€è‹¦æ‰‹å˜èªãŒ4èªä»¥ä¸Šå¿…è¦ã ã‚ˆï¼ˆæ¡ä»¶ã‚’ç·©ã‚ã¦ã­ï¼‰");
      try{ showGlobalFlash("bad", "è‹¦æ‰‹å˜èªãŒ4èªæœªæº€ã§ã™ï¼ˆæ¡ä»¶ã‚’ã‚†ã‚‹ã‚ã¦ã­ï¼‰"); }catch{}
      try{ if(elGlobalWeakInfo) elGlobalWeakInfo.textContent = "âš ï¸ è‹¦æ‰‹å˜èªãŒ4èªæœªæº€ã§ã™ï¼ˆé›†è¨ˆæ¡ä»¶ã‚’ã‚†ã‚‹ã‚ã¦ã­ï¼‰"; }catch{}
      return;
    }

    REVIEW_SET = picked.map(w => ({...w}));

    // ã‚°ãƒ­ãƒ¼ãƒãƒ«ä¿å­˜ï¼ˆCSVç„¡ã—ã§ã‚‚å¾©ç¿’ã§ãã‚‹ï¼‰
    saveGlobalReview(REVIEW_SET);

    // ç¾åœ¨ã®CSVå´ã«ã‚‚ä¿å­˜ã—ã¦ãŠãï¼ˆä¾¿åˆ©ï¼‰
    try { saveReviewToStorage(); } catch {}

    // å¾©ç¿’ONã«ã—ã¦å³ã‚¹ã‚¿ãƒ¼ãƒˆ
    if (elReviewMode) elReviewMode.value = "on";
    updateReviewStatus();
    needsResetAfterOverlayAction = true;
    overlayRequireManualResume = true;
    wasRunningBeforeOverlay = false;
    // â€»ã“ã“ã§ã¯è‡ªå‹•ã‚¹ã‚¿ãƒ¼ãƒˆã—ãªã„ï¼ˆå†é–‹ã¯ä¸€æ™‚åœæ­¢ãƒœã‚¿ãƒ³ã§ï¼‰
// â˜…é‡è¦ï¼šãƒ‘ãƒãƒ«ã¯é–‰ã˜ãªã„ï¼ˆå³ä¸Šã€Œé–‰ã˜ã‚‹ã€ã§ã®ã¿é–‰ã˜ã‚‹ï¼‰
    try{ if (elGlobalWeakPanel) elGlobalWeakPanel.style.display = "block"; }catch{}
    try{ if (elGlobalWeakBackdrop) elGlobalWeakBackdrop.style.display = "block"; }catch{}

    showFlash("good", `å…¨CSVã®è‹¦æ‰‹ã‹ã‚‰ ${REVIEW_SET.length}èªã‚’å¾©ç¿’ã‚»ãƒƒãƒˆã«ã—ãŸã‚ˆï¼ˆå†é–‹ã¯ä¸€æ™‚åœæ­¢ãƒœã‚¿ãƒ³ï¼‰`);
    try{ showGlobalFlash("good", `å¾©ç¿’ã‚»ãƒƒãƒˆæ›´æ–°: ${REVIEW_SET.length}èªï¼ˆå¾©ç¿’ONï¼‰`); }catch{}
    try{ if(elGlobalWeakInfo) elGlobalWeakInfo.textContent = `âœ… å¾©ç¿’ã‚»ãƒƒãƒˆæ›´æ–°: ${REVIEW_SET.length}èªï¼ˆå¾©ç¿’ONï¼‰`; }catch{}
  }

  function loadGlobalReviewIntoCurrent(){
    const arr = loadGlobalReviewFromStorage();
    if (!Array.isArray(arr) || arr.length < 4){
      showFlash("bad", "ä¿å­˜ã•ã‚ŒãŸç·åˆå¾©ç¿’ãŒãªã„ã‚ˆï¼ˆã¾ãšã€ã“ã®æ¡ä»¶ã§å…¨CSVè‹¦æ‰‹ã‚’å¾©ç¿’ã‚»ãƒƒãƒˆã«ã™ã‚‹ã€ã‚’æŠ¼ã—ã¦ã­ï¼‰");
      try{ showGlobalFlash("bad", "ä¿å­˜ã•ã‚ŒãŸç·åˆå¾©ç¿’ãŒã‚ã‚Šã¾ã›ã‚“"); }catch{}
      return;
    }

    REVIEW_SET = arr.map(w => ({...w}));
    if (elReviewMode) elReviewMode.value = "on";
    updateReviewStatus();
    needsResetAfterOverlayAction = true;
    overlayRequireManualResume = true;
    wasRunningBeforeOverlay = false;
    // â€»ã“ã“ã§ã¯è‡ªå‹•ã‚¹ã‚¿ãƒ¼ãƒˆã—ãªã„ï¼ˆå†é–‹ã¯ä¸€æ™‚åœæ­¢ãƒœã‚¿ãƒ³ã§ï¼‰
// â˜…ã“ã“é‡è¦ï¼šãƒ‘ãƒãƒ«ã¯é–‰ã˜ãªã„ï¼ˆå³ä¸Šã€Œé–‰ã˜ã‚‹ã€ã§ã®ã¿é–‰ã˜ã‚‹ï¼‰
    try{ if (elGlobalWeakPanel) elGlobalWeakPanel.style.display = "block"; }catch{}

    // ãƒ‘ãƒãƒ«å†…ã«ç¢ºå®Ÿã«é€šçŸ¥ï¼ˆè¦‹å¤±ã‚ãªã„ï¼‰
    try{ showGlobalFlash("good", `ç·åˆå¾©ç¿’ã‚’èª­ã¿è¾¼ã‚“ã ã‚ˆï¼ˆ${REVIEW_SET.length}èªï¼‰`); }catch{}

    // ã‚²ãƒ¼ãƒ å´ã«ã‚‚é€šçŸ¥
    showFlash("good", `ç·åˆå¾©ç¿’ã‚’èª­ã¿è¾¼ã‚“ã ã‚ˆï¼ˆ${REVIEW_SET.length}èªï¼‰ï¼ˆå†é–‹ã¯ä¸€æ™‚åœæ­¢ãƒœã‚¿ãƒ³ï¼‰`);
  }

  function beep(type) {
    try {
      const ctx = new (window.AudioContext || window.webkitAudioContext)();
      const o = ctx.createOscillator();
      const g = ctx.createGain();
      o.type = "sine";
      o.frequency.value = (type === "good") ? 880 : 220;
      g.gain.value = 0.0001;
      o.connect(g); g.connect(ctx.destination);
      o.start();
      const now = ctx.currentTime;
      g.gain.exponentialRampToValueAtTime(0.12, now + 0.01);
      g.gain.exponentialRampToValueAtTime(0.0001, now + 0.16);
      o.stop(now + 0.18);
      setTimeout(() => ctx.close(), 250);
    } catch {}
  }

  function showFlash(kind, text) {
    // ç·åˆè‹¦æ‰‹ãƒ©ãƒ³ã‚­ãƒ³ã‚°ãŒé–‹ã„ã¦ã„ã‚‹æ™‚ã¯ã€ãƒ¢ãƒ¼ãƒ€ãƒ«å†…ã«ã‚‚è¡¨ç¤ºï¼ˆã¯ã¿å‡ºã—é˜²æ­¢ï¼‰
    try {
      const p = document.getElementById("globalWeakPanel");
      const gf = document.getElementById("globalFlash");
      if (p && p.style.display !== "none" && gf) {
        gf.style.display = "block";
        gf.className = `flash ${kind}`;
        gf.textContent = text;
        // è¦‹ãˆã‚‹ä½ç½®ã¸
        gf.scrollIntoView({ block: "nearest", behavior: "smooth" });
        return;
      }
    } catch {}

    // é€šå¸¸ï¼ˆã‚²ãƒ¼ãƒ ç”»é¢ï¼‰
    elFlash.style.display = "block";
    elFlash.className = `flash ${kind}`;
    elFlash.textContent = text;
  }
  function clearChoices() { elChoices.innerHTML = ""; }
  function setLocked(v) {
    locked = v;
    [...elChoices.querySelectorAll("button")].forEach(b => b.disabled = v);
  }

  function renderHud() {
    elScore.textContent = String(score);
    elCombo.textContent = String(combo);
    const acc = answered === 0 ? 0 : Math.round((correct / answered) * 100);
    elAcc.textContent = `${acc}%`;

    const remain = (totalPlanned === Infinity)
      ? deck.length
      : Math.max(0, totalPlanned - askedCount);
    elRemaining.textContent = String(remain);
    if (elCsvHud) elCsvHud.textContent = CURRENT_CSV_NAME || "å†…è”µãƒ‡ãƒ¼ã‚¿";
  }

  // â‘¡ é•·æ–‡ã®ã¨ãè‡ªå‹•ã§å°‘ã—ç¸®ã‚ã‚‹ï¼ˆpromptã«fitã‚¯ãƒ©ã‚¹ä»˜ä¸ï¼‰
  function applyPromptFit(text) {
    const t = String(text || "");
    // ã–ã£ãã‚Šï¼šé•·ã„ã»ã©ç¸®å°ãŒåŠ¹ãï¼ˆCSS clampã§è‡ªç„¶ã«ï¼‰
    if (t.length >= 18) elPrompt.classList.add("fit");
    else elPrompt.classList.add("fit"); // å¸¸ã«fitã§OKï¼ˆçŸ­æ–‡ã§ã‚‚è‡ªç„¶ï¼‰
  }

  // =========================
  // Deck filter
  // =========================
  function applyDeckFilter() {
    const v = elDeckSelect ? elDeckSelect.value : "all";

    // â˜…é‡è¦: ã€Œå…¨éƒ¨ã€ã¯ level ã§ãƒ•ã‚£ãƒ«ã‚¿ãƒ¼ã—ãªã„ï¼ˆCSVãŒLv5ã‚„Lv10ã§ã‚‚å‹•ãã‚ˆã†ã«ï¼‰
    let allowed = null; // null = allow all levels
    if (v === "1") allowed = new Set([1]);
    if (v === "2") allowed = new Set([2]);
    if (v === "3") allowed = new Set([3]);
    if (v === "12") allowed = new Set([1,2]);
    if (v === "23") allowed = new Set([2,3]);

    WORDS = WORDS_ALL
      .filter(w => !allowed || allowed.has(Number(w.level ?? 0)))
      .map(w => ({
        en: w.en, ja: w.ja,
        level: Number(w.level ?? 1),
        lang: (w.lang || ""), en_lang: (w.en_lang || ""), ja_lang: (w.ja_lang || ""), tts: (w.tts || "")
      }));

    const name = (v === "all") ? "å…¨éƒ¨" : v;
    elDeckStatus.textContent = `ãƒ‡ãƒƒã‚­: ${name}ï¼ˆ${WORDS.length}èªï¼‰`;
  }

  // =========================
  // CSV parse (en,ja,level)
  // =========================
  function parseCSV(text) {
    // Robust CSV parser: supports quotes, commas inside quotes, and Excel BOM
    const raw = (text || "").replace(/\r/g, "");
    let lines = raw.split("\n");

    // drop leading/trailing empty lines
    while (lines.length && lines[0].trim() === "") lines.shift();
    while (lines.length && lines[lines.length-1].trim() === "") lines.pop();
    if (lines.length < 2) return [];

    // â˜…BOMé™¤å»ï¼ˆExcelç­‰ã®UTF-8 BOMä»˜ãCSVã§ã‚‚OKï¼‰
    lines[0] = lines[0].replace(/^\uFEFF/, "");

    function parseCSVLine(line){
      const out = [];
      let cur = "";
      let inQ = false;
      for (let i=0;i<line.length;i++){
        const ch = line[i];
        if (inQ){
          if (ch === '"'){
            // escaped quote
            if (i+1 < line.length && line[i+1] === '"'){ cur += '"'; i++; }
            else { inQ = false; }
          } else {
            cur += ch;
          }
        } else {
          if (ch === '"'){ inQ = true; }
          else if (ch === ','){ out.push(cur); cur=""; }
          else { cur += ch; }
        }
      }
      out.push(cur);
      return out.map(s => (s ?? "").trim());
    }

    const header = parseCSVLine(lines[0]).map(s => s.trim().toLowerCase());
    const enIdx = header.indexOf("en");
    const jaIdx = header.indexOf("ja");
    const lvIdx = header.indexOf("level");
    const langIdx = header.indexOf("lang"); // â˜…æ¨å¥¨ï¼ˆè¨€èªã‚¿ã‚°ï¼‰
    const enLangIdx = header.indexOf("en_lang"); // ä»»æ„
    const jaLangIdx = header.indexOf("ja_lang"); // ä»»æ„ï¼ˆå°†æ¥ç”¨ï¼‰
    const ttsIdx = header.indexOf("tts"); // ä»»æ„

    if (enIdx === -1 || jaIdx === -1) {
      throw new Error("CSVã®1è¡Œç›®ã¯ en,ja,levelï¼ˆlevelã¯ä»»æ„ï¼‰ã«ã—ã¦ã­");
    }

    const items = [];
    for (let i = 1; i < lines.length; i++) {
      const line = lines[i];
      if (!line || line.trim().length === 0) continue;
      const cols = parseCSVLine(line);

      const en = (cols[enIdx] ?? "").trim().replace(/^"(.*)"$/,"$1");
      const ja = (cols[jaIdx] ?? "").trim().replace(/^"(.*)"$/,"$1");

      let level = 1;
      if (lvIdx !== -1) {
        const rawLv = (cols[lvIdx] ?? "").trim().replace(/^"(.*)"$/,"$1");
        const n = Number(rawLv);
        level = Number.isFinite(n) && n >= 1 && n <= 99 ? n : 1;
      }

      const lang = ((langIdx !== -1 ? (cols[langIdx] ?? "").trim() : "") ||
                    (enLangIdx !== -1 ? (cols[enLangIdx] ?? "").trim() : "") || "")
                    .replace(/^"(.*)"$/,"$1");
      const en_lang = ((enLangIdx !== -1 ? (cols[enLangIdx] ?? "").trim() : "") || "").replace(/^"(.*)"$/,"$1");
      const ja_lang = ((jaLangIdx !== -1 ? (cols[jaLangIdx] ?? "").trim() : "") || "").replace(/^"(.*)"$/,"$1");
      const tts = ((ttsIdx !== -1 ? (cols[ttsIdx] ?? "").trim() : "") || "").replace(/^"(.*)"$/,"$1");

      if (!en || !ja) continue;
      items.push({ en, ja, level, lang, en_lang, ja_lang, tts });
    }
    return items;
  }

  // =========================
  // Review mode
  // =========================
  function updateReviewStatus() {
    const mode = elReviewMode?.value ?? "off";
    const n = REVIEW_SET.length;
    elReviewStatus.textContent =
      mode === "on" ? `å¾©ç¿’ON: ${n}èªã‚’ä½¿ã†` : `å¾©ç¿’OFF: é¸æŠæ¸ˆã¿ ${n}èª`;
  }

  function openReviewPicker() {
    const max = clamp(parseInt(elReviewCount?.value || "10", 10), 4, 50);
    elReviewMax.textContent = String(max);

    elReviewList.innerHTML = "";
    const selected = new Set(REVIEW_SET.map(w => w.en + "||" + w.ja + "||" + w.level));

    WORDS.forEach((w) => {
      const key = w.en + "||" + w.ja + "||" + w.level;

      const row = document.createElement("label");
      row.style.display = "flex";
      row.style.gap = "10px";
      row.style.alignItems = "center";
      row.style.padding = "6px 4px";
      row.style.borderBottom = "1px solid rgba(255,255,255,.08)";
      row.style.cursor = "pointer";

      const cb = document.createElement("input");
      cb.type = "checkbox";
      cb.checked = selected.has(key);

      cb.addEventListener("change", () => {
        const checked = elReviewList.querySelectorAll("input[type=checkbox]:checked").length;
        if (checked > max) {
          cb.checked = false;
          showFlash("bad", `æœ€å¤§${max}èªã¾ã§ã ã‚ˆ`);
        }
      });

      const txt = document.createElement("div");
      txt.innerHTML = `<b>${escapeHtml(w.ja)}</b> <span class="small">â†” ${escapeHtml(w.en)}ï¼ˆLv${w.level}ï¼‰</span>`;

      row.appendChild(cb);
      row.appendChild(txt);
      elReviewList.appendChild(row);
    });

    elReviewPanel.style.display = "block";
  }

  function saveReviewPicker() {
    const max = clamp(parseInt(elReviewCount?.value || "10", 10), 4, 50);
    const picked = [];

    const rows = elReviewList.querySelectorAll("label");
    rows.forEach((row, idx) => {
      const cb = row.querySelector("input[type=checkbox]");
      if (!cb || !cb.checked) return;
      if (picked.length >= max) return;
      picked.push(WORDS[idx]);
    });

    REVIEW_SET = picked.map(w => ({ ...w }));
    saveReviewToStorage();
    elReviewPanel.style.display = "none";
    updateReviewStatus();
    
    const _wasPaused = isPaused;
    if (_wasPaused) {
      // ä¸€æ™‚åœæ­¢ä¸­ã«å¾©ç¿’ã‚»ãƒƒãƒˆã‚’ä¿å­˜ã—ãŸå ´åˆã¯ã€å‹æ‰‹ã«å†é–‹ã—ãªã„
      needsResetAfterOverlayAction = true; // å†é–‹æ™‚ã«åæ˜ ã™ã‚‹
      showFlash("good", "å¾©ç¿’ã‚»ãƒƒãƒˆã‚’ä¿å­˜ã—ãŸã‚ˆï¼ˆä¸­æ–­ã®ã¾ã¾ï¼‰ã€‚å†é–‹ã™ã‚‹ã¨ãã¯ã€Œçµæœã‚’è¦‹ã‚‹ã€ã‚’æŠ¼ã—ã¦ã­");
      return;
    }
    resetGame();
  }

  function clearReviewSet() {
    REVIEW_SET = [];
    clearReviewFromStorage();
    updateReviewStatus();
    
    const _wasPaused = isPaused;
    if (_wasPaused) {
      needsResetAfterOverlayAction = true;
      showFlash("good", "å¾©ç¿’ã‚’ã‚¯ãƒªã‚¢ã—ãŸã‚ˆï¼ˆä¸­æ–­ã®ã¾ã¾ï¼‰ã€‚å†é–‹ã™ã‚‹ã¨ãã¯ã€Œçµæœã‚’è¦‹ã‚‹ã€ã‚’æŠ¼ã—ã¦ã­");
      return;
    }
    resetGame();
  }

  // =========================
  // Weak auto-pick (uses result filter)
  // =========================
  function autoPickWeakWords() {
    const MIN_SEEN = clamp(parseInt(elResultMinSeen?.value || "5", 10), 1, 9999);
    const th = clamp(parseInt(elWeakThreshold?.value || "30", 10), 0, 100) / 100;

    const candidates = Array.from(STATS.values())
      .filter(r => (r.seen || 0) >= MIN_SEEN)
      .map(r => ({ r, acc: r.seen ? (r.correct / r.seen) : 1 }))
      .filter(x => x.acc < th)
      .sort((a, b) => {
        if (a.acc !== b.acc) return a.acc - b.acc; // lower acc first
        if ((a.r.seen || 0) !== (b.r.seen || 0)) return (b.r.seen || 0) - (a.r.seen || 0); // more data first
        return (b.r.wrong || 0) - (a.r.wrong || 0); // then more wrong
      });

    const max = clamp(parseInt(elReviewCount?.value || "10", 10), 4, 50);

    const picked = [];
    for (const x of candidates) {
      if (picked.length >= max) break;
      const found = WORDS_ALL.find(w =>
        w.en === x.r.en && w.ja === x.r.ja && Number(w.level) === Number(x.r.level)
      );
      if (found) picked.push({ ...found });
    }

    REVIEW_SET = picked;
    saveReviewToStorage();

    if (elReviewMode) elReviewMode.value = "on";
    updateReviewStatus();

    if (REVIEW_SET.length === 0) {
      showFlash("bad", `è‹¦æ‰‹ãŒè¦‹ã¤ã‹ã‚‰ãªã‹ã£ãŸï¼ˆå‡ºé¡Œ${MIN_SEEN}å›ä»¥ä¸Šã§ã€æ­£è§£ç‡${Math.round(th*100)}%æœªæº€ãŒ0ä»¶ï¼‰`);
      return;
    }

    showFlash("good", `è‹¦æ‰‹ã‚’è‡ªå‹•ã‚»ãƒƒãƒˆ: ${REVIEW_SET.length}èªï¼ˆæ­£è§£ç‡${Math.round(th*100)}%æœªæº€ï¼‰`);
    resetGame();
  }

  // =========================
  // Results
  // =========================
  function showResults(){
    const MIN_SEEN = clamp(parseInt(elResultMinSeen?.value || "1", 10), 1, 9999);
    const rows = Array.from(STATS.values()).filter(r => (r.seen || 0) >= MIN_SEEN);

    if (!rows.length) {
      elResultSummary.textContent = `è¡¨ç¤ºæ¡ä»¶ã«åˆã†å˜èªãŒã‚ã‚Šã¾ã›ã‚“ï¼ˆå‡ºé¡Œ${MIN_SEEN}å›ä»¥ä¸Šï¼‰`;
      elResultTable.innerHTML = `<div class="small" style="opacity:.9;">ãƒ’ãƒ³ãƒˆï¼šä¸Šã®ã€Œè¡¨ç¤º: å‡ºé¡Œå›æ•°ã€ã‚’ <b>1å›ä»¥ä¸Š</b> ã«ã™ã‚‹ã¨å…¨éƒ¨å‡ºã¾ã™ã€‚</div>`;
      elResultPanel.style.display = "block";
      return;
    }

    const totalSeen = rows.reduce((a,r)=>a+(r.seen||0),0);
    const totalCorrect = rows.reduce((a,r)=>a+(r.correct||0),0);
    const totalWrong = rows.reduce((a,r)=>a+(r.wrong||0),0);
    const totalSkip = rows.reduce((a,r)=>a+(r.skip||0),0);

    rows.sort((a, b) => {
      const aSeen = a.seen || 0;
      const bSeen = b.seen || 0;

      const aAcc = aSeen ? (a.correct / aSeen) : 1;
      const bAcc = bSeen ? (b.correct / bSeen) : 1;

      const aZero = aSeen > 0 && (a.correct || 0) === 0;
      const bZero = bSeen > 0 && (b.correct || 0) === 0;

      if (aZero !== bZero) return aZero ? -1 : 1;     // 0% fixed at top
      if (aAcc !== bAcc) return aAcc - bAcc;          // lower acc first
      if (aSeen !== bSeen) return bSeen - aSeen;      // more data first
      return (b.wrong || 0) - (a.wrong || 0);         // then more wrong
    });

    const acc = totalSeen ? Math.round((totalCorrect/totalSeen)*100) : 0;
    elResultSummary.textContent =
      `ç·å‡ºé¡Œ:${totalSeen} / æ­£è§£:${totalCorrect} / ä¸æ­£è§£:${totalWrong} / ã‚¹ã‚­ãƒƒãƒ—:${totalSkip} / æ­£è§£ç‡:${acc}%ï¼ˆè¡¨ç¤º: å‡ºé¡Œ${MIN_SEEN}å›ä»¥ä¸Šï¼‰`;

    const html = `
      <table style="width:100%;border-collapse:collapse;">
        <thead>
          <tr>
            <th style="text-align:left;padding:6px;border-bottom:1px solid rgba(255,255,255,.12);">ãƒšã‚¢</th>
            <th style="text-align:right;padding:6px;border-bottom:1px solid rgba(255,255,255,.12);">Lv</th>
            <th style="text-align:right;padding:6px;border-bottom:1px solid rgba(255,255,255,.12);">å‡ºé¡Œ</th>
            <th style="text-align:right;padding:6px;border-bottom:1px solid rgba(255,255,255,.12);">ä¸æ­£è§£</th>
            <th style="text-align:right;padding:6px;border-bottom:1px solid rgba(255,255,255,.12);">ã‚¹ã‚­ãƒƒãƒ—</th>
            <th style="text-align:right;padding:6px;border-bottom:1px solid rgba(255,255,255,.12);">æ­£è§£ç‡</th>
            <th style="text-align:right;padding:6px;border-bottom:1px solid rgba(255,255,255,.12);">é–“é•ã„ç‡</th>
            <th style="text-align:right;padding:6px;border-bottom:1px solid rgba(255,255,255,.12);">é–“é•ã„ãƒ‘ã‚¿ãƒ¼ãƒ³</th>
          </tr>
        </thead>
        <tbody>
          ${rows.map(r=>{
            const attempts = r.seen || 0;
            const correctRate = attempts ? Math.round((r.correct / attempts) * 100) : 0;
            const wrongRate   = attempts ? Math.round((r.wrong / attempts) * 100) : 0;
            const isBad = correctRate <= 30;
            const patterns = r.wrongChoices ? r.wrongChoices.size : 0;

            return `
              <tr>
                <td style="padding:6px;border-bottom:1px solid rgba(255,255,255,.08);">
                  <b>${escapeHtml(r.ja)}</b>
                  <div class="small">â†” ${escapeHtml(r.en)}</div>
                </td>
                <td style="text-align:right;padding:6px;border-bottom:1px solid rgba(255,255,255,.08);">${r.level}</td>
                <td style="text-align:right;padding:6px;border-bottom:1px solid rgba(255,255,255,.08);">${attempts}</td>
                <td style="text-align:right;padding:6px;border-bottom:1px solid rgba(255,255,255,.08);">${r.wrong||0}</td>
                <td style="text-align:right;padding:6px;border-bottom:1px solid rgba(255,255,255,.08);">${r.skip||0}</td>

                <td style="
                  text-align:right;
                  padding:6px;
                  border-bottom:1px solid rgba(255,255,255,.08);
                  color:${isBad ? '#ff5c7a' : '#e8eeff'};
                  font-weight:${isBad ? '800' : '400'};
                ">
                  ${correctRate}%
                </td>

                <td style="
                  text-align:right;
                  padding:6px;
                  border-bottom:1px solid rgba(255,255,255,.08);
                  color:${wrongRate >= 70 ? '#ff9a5c' : '#a9b3d6'};
                ">
                  ${wrongRate}%
                </td>

                <td style="text-align:right;padding:6px;border-bottom:1px solid rgba(255,255,255,.08);">${patterns}</td>
              </tr>`;
          }).join("")}
        </tbody>
      </table>`;

    elResultTable.innerHTML = html;
    elResultPanel.style.display = "block";
  }
// =========================
  // Game logic (æ–¹å‘å¯¾å¿œ)
  // =========================
  function getPromptText(w) {
    return (getDirection() === "ja2en") ? w.ja : w.en;
  }
  function getAnswerText(w) {
    return (getDirection() === "ja2en") ? w.en : w.ja;
  }
  function getChoicePool() {
    // é¸æŠè‚¢ã¯ã€Œç­”ãˆå´ã€
    return WORDS.map(w => getAnswerText(w));
  }
  function buildChoices(word) {
    const answer = getAnswerText(word);
    const distractors = pickN(getChoicePool(), 3, answer);
    return shuffle([answer, ...distractors]);
  }

  function scheduleTimer(startRemain = secondsPerQ) {
    cancelAnimationFrame(rafId);

    const start = performance.now();
    const startValue = startRemain;

    function tick(now) {
      if (isPaused) return;

      const elapsed = (now - start) / 1000;
      const remain = Math.max(0, startValue - elapsed);
      pausedRemain = remain;

      elTime.textContent = remain.toFixed(1);

      const ratio = remain / secondsPerQ;
      elBar.style.transform = `scaleX(${Math.max(0, ratio)})`;

      if (remain <= 0 && !locked) {
        handleSkip(true);
        return;
      }
      rafId = requestAnimationFrame(tick);
    }

    rafId = requestAnimationFrame(tick);
  }

  // âˆãƒ¢ãƒ¼ãƒ‰ã ã‘ã€Œæˆ»ã™ã€
  function reinsertWord(word, when) {
    let idx;
    if (when === "front") {
      idx = Math.floor(Math.random() * Math.max(1, reviewWeight));
    } else if (when === "mid") {
      idx = Math.floor(deck.length * 0.35 + Math.random() * Math.max(1, deck.length * 0.15));
    } else {
      idx = Math.floor(deck.length * 0.7 + Math.random() * Math.max(1, deck.length * 0.25));
    }
    idx = clamp(idx, 0, deck.length);
    deck.splice(idx, 0, word);
  }

  function endGame() {
    cancelAnimationFrame(rafId);
    clearChoices();
    elPrompt.textContent = "çµ‚äº†ï¼";
    elTime.textContent = "0.0";
    elBar.style.transform = "scaleX(0)";
    showFlash("good", `ãŠã¤ã‹ã‚Œï¼ ã‚¹ã‚³ã‚¢: ${score} / æ­£è§£ç‡: ${elAcc.textContent}`);
    showResults();
  }

  function updateModeLabel() {
    const d = getDirection();
    elModeLabel.textContent = (d === "ja2en") ? "æ—¥æœ¬èª â†’ è‹±èªï¼ˆ4æŠï¼‰" : "è‹±èª â†’ æ—¥æœ¬èªï¼ˆ4æŠï¼‰";
  }

  function nextQuestion() {
    if (askedCount >= totalPlanned && totalPlanned !== Infinity) {
      endGame();
      return;
    }
    if (deck.length === 0) {
      if (totalPlanned === Infinity) rebuildInfiniteDeck();
      else { endGame(); return; }
    }

    current = deck.shift();
    askedCount++;

    ensureStat(current).seen++;
    try{ dailyInc('seen', 1); }catch(e){}
    scheduleSaveStats();

    locked = false;
    updateModeLabel();

    const promptText = getPromptText(current);
    elPrompt.textContent = promptText;

    // â˜…å•é¡ŒãŒåˆ‡ã‚Šæ›¿ã‚ã‚‹ãŸã³ã«éŸ³å£°è¡¨ç¤ºã‚‚è‡ªå‹•æ›´æ–°ï¼ˆğŸ”Šã‚’æŠ¼ã•ãªãã¦ã‚‚åæ˜ ï¼‰
    updateTtsHint(getForeignLangHint(current));
    applyPromptFit(promptText);

    // â˜…è‹±èªâ†’æ—¥æœ¬èªã®ã¨ãã ã‘ï¼šå•é¡ŒãŒå‡ºãŸç¬é–“ã«1å›ã ã‘è‡ªå‹•èª­ã¿ä¸Šã’ï¼ˆè‹±èªå´ï¼‰
    if (getDirection() === "en2ja" && (elAutoSpeak?.value || "on") === "on") {
      setTimeout(() => { speakText(current.en, getForeignLangHint(current), { mode: "auto" }); }, 200);
    }

    clearChoices();
    elFlash.className = "flash"; elFlash.textContent = ""; elFlash.style.display = "none";

    const options = buildChoices(current);
    options.forEach((opt, idx) => {
      const btn = document.createElement("button");
      btn.className = "choice";
      btn.innerHTML = `<span class="small">(${idx+1})</span>  <span class="choiceText">${escapeHtml(opt)}</span>`;
      btn.addEventListener("click", () => handleAnswer(opt));
      elChoices.appendChild(btn);
    });

    renderHud();
    scheduleTimer(isPaused ? (pausedRemain ?? secondsPerQ) : secondsPerQ);
  }

  // =========================
  // TTS
  // =========================
  let voices = [];
  function listVoices() {
    voices = window.speechSynthesis ? window.speechSynthesis.getVoices() : [];
    elVoiceSelect.innerHTML = "";

    // â˜…AUTOï¼ˆè¨€èªã«åˆã‚ã›ã‚‹ï¼‰
    const optAuto = document.createElement("option");
    optAuto.value = "auto";
    optAuto.textContent = "AUTOï¼ˆè¨€èªã«åˆã‚ã›ã‚‹ï¼‰";
    elVoiceSelect.appendChild(optAuto);


    if (!voices.length) {
      const opt = document.createElement("option");
      opt.value = "";
      opt.textContent = "ï¼ˆéŸ³å£°ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ï¼‰";
      elVoiceSelect.appendChild(opt);
      elTtsHint.textContent = "ãƒ’ãƒ³ãƒˆ: Chromeã®ã»ã†ãŒéŸ³å£°ãŒå……å®Ÿã—ã¦ã‚‹ã“ã¨ãŒå¤šã„ã‚ˆ";
      return;
    }

    // Autoå„ªå…ˆ: è‹±èª(en-US) ã¨ æ—¥æœ¬èª(ja-JP)ã‚’ä¸Šã«æŒã£ã¦ãã‚‹
    const scoreLang = (lang) => {
      if (!lang) return 999;
      lang = lang.toLowerCase();
      if (lang.includes("en-us")) return 0;
      if (lang.includes("ja-jp")) return 1;
      if (lang.startsWith("en")) return 2;
      if (lang.startsWith("ja")) return 3;
      return 10;
    };

    const sorted = voices.slice().sort((a,b)=>{
      const sa = scoreLang(a.lang), sb = scoreLang(b.lang);
      if (sa !== sb) return sa - sb;
      return (a.name || "").localeCompare(b.name || "");
    });

    sorted.forEach((v) => {
      const opt = document.createElement("option");
      opt.value = String(voices.indexOf(v));
      opt.textContent = `${v.name} (${v.lang})`;
      elVoiceSelect.appendChild(opt);
    });

    elVoiceSelect.selectedIndex = 0;

    // â˜…éŸ³å£°ä¸€è¦§ãŒæƒã£ãŸã‚¿ã‚¤ãƒŸãƒ³ã‚°ã§ã€ç¾åœ¨ã®å•é¡Œã«åˆã‚ã›ã¦è¡¨ç¤ºã‚‚æ›´æ–°
    if (typeof current !== 'undefined' && current) {
      updateTtsHint(getForeignLangHint(current));
    }
  }

  function cleanForSpeech(text) {
    if (!text) return "";
    return String(text)
      .replace(/ï¼ˆ.*?ï¼‰/g, "")
      .replace(/\(.*?\)/g, "")
      .replace(/[â€œâ€"ã€Œã€]/g, "")
      .trim();
  }

  function pickVoiceFor(langHint) {
    if (!voices.length) return null;

    const sel = (elVoiceSelect.value || "auto");
    // æ‰‹å‹•é¸æŠï¼ˆAUTOä»¥å¤–ï¼‰ãªã‚‰ãã‚Œã‚’ä½¿ã†
    if (sel !== "auto") {
      const idx = parseInt(sel, 10);
      if (Number.isFinite(idx) && voices[idx]) return voices[idx];
    }

    const hint = (langHint || "").trim().toLowerCase();

    // 1) å®Œå…¨ä¸€è‡´ï¼ˆä¾‹: zh-twï¼‰
    let v =
      voices.find(x => (x.lang || "").trim().toLowerCase() === hint);
    if (v) return v;

    // 2) å…ˆé ­ä¸€è‡´ï¼ˆä¾‹: zh- ãªã‚‰ zh-xxï¼‰
    const base = hint.split("-")[0];
    if (base) {
      v = voices.find(x => ((x.lang || "").trim().toLowerCase().split("-")[0] === base));
      if (v) return v;
    }

    // 3) éƒ¨åˆ†ä¸€è‡´ï¼ˆä¿é™ºï¼‰
    v = voices.find(x => ((x.lang || "").toLowerCase().includes(hint)));
    if (v) return v;

    // 4) æœ€å¾Œã®æ‰‹æ®µ: è‹±èªâ†’æ—¥æœ¬èªâ†’å…ˆé ­
    return voices.find(x => (x.lang || "").toLowerCase().startsWith("en"))
      || voices.find(x => (x.lang || "").toLowerCase().startsWith("ja"))
      || voices[0];
  }

  function guessLangHintFromText(t) {
    // ã–ã£ãã‚Šåˆ¤å®šï¼ˆen_langãŒç„¡ã„ã¨ãã®ä¿é™ºï¼‰
    const s = (t || "").trim();
    if (!s) return "";
    if (/[\uAC00-\uD7A3]/.test(s)) return "ko-KR";    // Hangul
    if (/[\u3040-\u30FF]/.test(s)) return "ja-JP";    // Kana
    if (/[\u4E00-\u9FFF]/.test(s)) return "zh-TW";    // Hanï¼ˆå°æ¹¾å¯„ã›ï¼‰
    if (/[A-Za-z]/.test(s)) return "en-US";
    return "";
  }

  function normalizeLangHint(hint) {
    const h = (hint || "").trim();
    // å°æ¹¾èªï¼ˆnan-TWï¼‰ãŒç„¡ã„ç«¯æœ«ãŒå¤šã„ã®ã§ã€ç„¡ã‘ã‚Œã°å°æ¹¾è¯èªã«å¯„ã›ã‚‹
    if (/^nan(-tw)?$/i.test(h) || /^nan-tw$/i.test(h)) return "nan-TW";
    return h;
  }

  function getForeignLangHint(w) {
    // æ—¥æœ¬èªå›ºå®šé‹ç”¨: å¤–å›½èªå´ï¼ˆenåˆ—ï¼‰ã®è¨€èªãƒ’ãƒ³ãƒˆ
    const raw = (w && w.en_lang) ? w.en_lang : "";
    const normalized = normalizeLangHint(raw);
    return normalized || guessLangHintFromText(w ? w.en : "");
  }

  function updateTtsHint(langHint) {
    if (!voices || !voices.length) { elTtsHint.textContent = ""; return; }
    const v = pickVoiceFor(langHint);
    if (v) elTtsHint.textContent = `ç¾åœ¨ã®éŸ³å£°: ${v.name} / ${v.lang}`;
    else elTtsHint.textContent = "";
  }

  function speakText(rawText, langHint, opts = {}) {
    const synth = window.speechSynthesis;
    if (!synth) {
      showFlash("bad", "ã“ã®ãƒ–ãƒ©ã‚¦ã‚¶ã¯èª­ã¿ä¸Šã’ã«å¯¾å¿œã—ã¦ãªã„ã¿ãŸã„");
      return;
    }
    const text = cleanForSpeech(rawText);
    if (!text) return;

    const mode = (opts && opts.mode) ? String(opts.mode) : "manual"; // "manual" | "auto"
    const isAuto = (mode === "auto");

    // éŸ³å£°ãƒ¢ãƒ¼ãƒ‰ï¼ˆæ‰‹å‹•/è‡ªå‹•ã¨ã¯åˆ¥ã®ã€ŒéŸ³æºã€åˆ‡æ›¿ï¼‰
    if (VOICE_MODE === "online") {
      const lp = (langHint || "en").split("-")[0];
      // è‡ªå‹•ã®å ´åˆã¯é€£æ‰“ã§ã†ã‚‹ã•ããªã‚‰ãªã„ã‚ˆã†ã« speaking/pending ã£ã½ã„æ™‚ã¯ã‚¹ã‚­ãƒƒãƒ—
      if (isAuto) {
        // ã‚ªãƒ³ãƒ©ã‚¤ãƒ³ã¯ speaking çŠ¶æ…‹ãŒå–ã‚Œãªã„ã®ã§ã€ã“ã“ã§ã¯ã‚¹ã‚­ãƒƒãƒ—ã—ãªã„ï¼ˆçŸ­æ–‡å‰æï¼‰
      }
      speakOnline(text, lp, isAuto);
      return;
    }

    // â˜…AUTO ã¯ã€Œã„ã¾å–‹ã£ã¦ãŸã‚‰ã‚¹ã‚­ãƒƒãƒ—ã€ã—ã¦ãƒã‚¤ã‚ºã‚’é¿ã‘ã‚‹
    if (isAuto) {
      if (synth.speaking || synth.pending) return;
      // cancelã—ãªã„ï¼ˆãƒ–ãƒ„åˆ‡ã‚ŠéŸ³å¯¾ç­–ï¼‰
    } else {
      // æ‰‹å‹•ã¯ã€ŒæŠ¼ã—ãŸã‚‰ç¢ºå®Ÿã«èª­ã‚€ã€ãŸã‚ã«ã‚­ãƒ£ãƒ³ã‚»ãƒ«OK
      synth.cancel();
    }

    const u = new SpeechSynthesisUtterance(text);
    let v = pickVoiceFor(langHint);
    if (!v) {
      const h = (langHint || "").toLowerCase();
      // â˜…ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ï¼ˆnan-TWãŒç„¡ã„ã¨ãç­‰ï¼‰
      if (h.startsWith("nan")) v = pickVoiceFor("zh-TW") || pickVoiceFor("zh-CN") || pickVoiceFor("en-US");
      else if (h.startsWith("zh")) v = pickVoiceFor("zh-TW") || pickVoiceFor("zh-CN") || pickVoiceFor("en-US");
      else v = pickVoiceFor("en-US");
    }
    if (v) u.voice = v;

    // â˜…å®Ÿéš›ã«ä½¿ã†éŸ³å£°ã‚’è¡¨ç¤ºï¼ˆã‚ªãƒ¼ãƒˆé€£å‹•ï¼‰
    if (v) elTtsHint.textContent = `ç¾åœ¨ã®éŸ³å£°: ${v.name} / ${v.lang}`;
    else elTtsHint.textContent = "";

    u.rate = parseFloat(elRate.value || "1.0");
    u.volume = parseFloat(elVolume.value || "1.0");
    u.lang = (v && v.lang) ? v.lang : (langHint || "en-US");

    
    // === TTS LOCK hook ===
    acquireTtsLock();
    try{ updateTtsHud && updateTtsHud(); }catch(e){}
    synth.speak(u);
    
  }

  function speakCurrent() {
    if (!current) { showFlash("bad", "ã¾ã å•é¡ŒãŒãªã„ã‚ˆ"); return; }
    // â˜…æ—¥æœ¬èªå›ºå®šé‹ç”¨: ğŸ”Šã¯å¸¸ã«å¤–å›½èªå´ï¼ˆenåˆ—ï¼‰ã‚’èª­ã‚€ï¼ˆen_langãŒã‚ã‚Œã°é€£å‹•ï¼‰
    speakText(current.en, getForeignLangHint(current), { mode: "manual" });
  }

  function stopSpeech() {
    
    if (window.speechSynthesis) window.speechSynthesis.cancel();
    releaseTtsLock();
    try{ updateTtsHud && updateTtsHud(); }catch(e){}
    
  }

  // =========================
  // Answer handling (æ–¹å‘å¯¾å¿œ + è‡ªå‹•ç™ºéŸ³)
  // =========================
  function handleAnswer(selected) {
    if (locked) return;
    setLocked(true);
    answered++;

    const answer = getAnswerText(current);
    const isCorrect = selected === answer;
    const st = ensureStat(current);

    if (isCorrect) st.correct++;
    else {
      st.wrong++;
      st.wrongChoices.add(selected);
    }
    scheduleSaveStats();
    try{ dailyInc(isCorrect ? 'correct' : 'wrong', 1); }catch(e){}

    if (isCorrect) {
      correct++;
      combo++;
      const remain = parseFloat(elTime.textContent);

      // 0ã€œ1ï¼ˆæ®‹ã‚Šæ™‚é–“ã®å‰²åˆï¼‰
      const ratio = Math.max(0, Math.min(1, remain / secondsPerQ));

      // åŸºç¤ç‚¹
      const base = 10;

      // ã‚¹ãƒ”ãƒ¼ãƒ‰ç‚¹ï¼šæ—©ã„ã»ã©å¤§ãã„ï¼ˆæœ€å¤§+40ï¼‰
      const speedBonus = Math.round(40 * (ratio ** 2));

      // ã‚³ãƒ³ãƒœç‚¹
      const comboBonus = combo * 2;

      const gain = base + speedBonus + comboBonus;
      score += gain;
      showFlash("good", `æ­£è§£ï¼ +${gain}  ã‚³ãƒ³ãƒœx${combo}`);
      beep("good");

      // â˜…æ—¥æœ¬èªâ†’è‹±èª(ja2en)ã®ã¨ãã¯ã€æ­£è§£å¾Œã«ã€Œç­”ãˆã®è‹±èªã€ã‚’1å›ã ã‘è‡ªå‹•èª­ã¿ä¸Šã’
      //    â€»AUTOã¯ cancelã—ãªã„ï¼†ç™ºè©±ä¸­ãªã‚‰ã‚¹ã‚­ãƒƒãƒ—ï¼ˆã‚¯ãƒªãƒƒã‚¯éŸ³å¯¾ç­–ï¼‰
      if (getDirection() === "ja2en") {
        const ansToSpeak = answer;
        const langToSpeak = getForeignLangHint(current);
        setTimeout(() => {
          speakText(ansToSpeak, langToSpeak, { mode: "auto" });
        }, 120);
      }

      if (roundsMode === Infinity) reinsertWord(current, "back");
    } else {
      combo = 0;
      showFlash("bad", `ä¸æ­£è§£â€¦ æ­£è§£ã¯ã€Œ${answer}ã€`);
      beep("bad");
      if (roundsMode === Infinity) reinsertWord(current, "front");
    }

    renderHud();
    setTimeout(() => { setLocked(false); nextQuestion(); }, 520);
  }

  function handleSkip(isTimeout=false) {
    if (locked) return;
    setLocked(true);
    combo = 0;
    answered++;

    const st = ensureStat(current);
    st.skip++;
    try{ dailyInc('skip', 1); }catch(e){}
    scheduleSaveStats();

    const ans = getAnswerText(current);
    showFlash("bad", isTimeout ? `æ™‚é–“åˆ‡ã‚Œâ€¦ æ­£è§£ã¯ã€Œ${ans}ã€` : `ã‚¹ã‚­ãƒƒãƒ—: å¾©ç¿’ã«å›ã™ï¼ˆæ­£è§£: ${ans}ï¼‰`);
    beep("bad");
    if (roundsMode === Infinity) reinsertWord(current, "front");

    renderHud();
    setTimeout(() => { setLocked(false); nextQuestion(); }, 420);
  }

  function rebuildInfiniteDeck() {
    let ACTIVE = filterByLang(WORDS);
    const mode = elReviewMode?.value ?? "off";
    if (mode === "on" && REVIEW_SET.length >= 4) {
      // å¾©ç¿’ãƒ¢ãƒ¼ãƒ‰ä¸­ã§ã‚‚ã€è¨€èªãƒ•ã‚£ãƒ«ã‚¿ãƒ¼ã§å¾©ç¿’ã‚»ãƒƒãƒˆãŒè¶³ã‚Šãªã„å ´åˆã¯é€šå¸¸ã®å˜èªãƒªã‚¹ãƒˆã«åˆ‡ã‚Šæ›¿ãˆã‚‹
      const tmp = filterByLang(REVIEW_SET);
      if (tmp.length >= 4) {
        ACTIVE = tmp;
      } else {
        ACTIVE = filterByLang(WORDS);
      }
    }

    deck = shuffle(ACTIVE).map(w => ({...w}));
    totalPlanned = Infinity;
    askedCount = 0;
  }

  function resetGame() {
    cancelAnimationFrame(rafId);

    secondsPerQ = clamp(parseFloat(elSecondsPerQ.value || "6"), 1, 30);
    reviewWeight = clamp(parseInt(elReviewWeight.value || "5", 10), 1, 10);

    score = 0; combo = 0; correct = 0; answered = 0;
    // STATSã¯ä¿å­˜ã•ã‚Œã¦ã„ã‚‹æˆç¸¾ã‚’ç¶­æŒï¼ˆãƒªã‚¹ã‚¿ãƒ¼ãƒˆã§æ¶ˆã•ãªã„ï¼‰

    elResultPanel.style.display = "none";
    elFlash.className = "flash"; elFlash.textContent = ""; elFlash.style.display = "none";

    applyDeckFilter();
    updateModeLabel();

    let ACTIVE = filterByLang(WORDS);
    const mode = elReviewMode?.value ?? "off";
    if (mode === "on" && REVIEW_SET.length >= 4) ACTIVE = filterByLang(REVIEW_SET);

    debugActiveStatus(ACTIVE);

    if (SELECTED_LANGS.size > 0 && ACTIVE.length === 0) {
      showFlash("bad", "é¸ã‚“ã è¨€èªã®å˜èªãŒ0ä»¶ã ã‚ˆï¼ˆå¾©ç¿’ãƒ¢ãƒ¼ãƒ‰ä¸­ãªã‚‰å¾©ç¿’ãƒ‡ãƒ¼ã‚¿ãŒãã®è¨€èªã«ç„¡ã„å ´åˆã‚‚ã‚ã‚‹ã‚ˆï¼‰");
    }

    if (ACTIVE.length < 4) {
      clearChoices();
      elPrompt.textContent = "å˜èªãŒè¶³ã‚Šãªã„â€¦";
      showFlash("bad", "4æŠãªã®ã§ã€4èªä»¥ä¸Šå¿…è¦ã ã‚ˆã€‚ãƒ‡ãƒƒã‚­/CSVã‚’è¦‹ç›´ã—ã¦ã­ã€‚");
      totalPlanned = 0;
      askedCount = 0;
      renderHud();
      return;
    }

    const rv = elRounds?.value ?? "1";
    roundsMode = (rv === "inf") ? Infinity : clamp(parseInt(rv, 10), 1, 10);
    askedCount = 0;

    if (roundsMode === Infinity) {
      deck = shuffle(ACTIVE).map(w => ({...w}));
      totalPlanned = Infinity;
    } else {
      const merged = [];
      for (let r = 0; r < roundsMode; r++) merged.push(...ACTIVE.map(w => ({...w})));
      deck = shuffle(merged);
      totalPlanned = deck.length;
    }

    isPaused = false;
    pausedRemain = null;

    elBar.style.transform = "scaleX(1)";
    nextQuestion();
  }

  // =========================
  // Pause + results
  // =========================
  function pauseGame() {
    if (isPaused) return;
    isPaused = true;
    showFlash("good", "â¸ ä¸€æ™‚åœæ­¢ä¸­");
  }

  function resumeGame() {
    if (!isPaused) return;
    isPaused = false;
    elResultPanel.style.display = "none";
    scheduleTimer(pausedRemain ?? secondsPerQ);
  }

  // =========================
  // Events
  // =========================
  elSkip.addEventListener("click", () => handleSkip(false));
  elRestart.addEventListener("click", () => resetGame());

  // Daily log UI
  const elToggleDailyPanel = document.getElementById("toggleDailyPanel");
  const elDailyPanel = document.getElementById("dailyPanel");
  const elResetToday = document.getElementById("resetToday");

  elToggleDailyPanel?.addEventListener("click", () => {
    if(!elDailyPanel) return;
    const on = elDailyPanel.style.display !== "none";
    elDailyPanel.style.display = on ? "none" : "block";
    // é–‹ã„ãŸç¬é–“ã«æœ€æ–°è¡¨ç¤º
    try{ renderDailyUI(); }catch(e){}
    if(!on) showFlash("good", "å­¦ç¿’å±¥æ­´ã‚’è¡¨ç¤ºã—ãŸã‚ˆ");
  });

  elResetToday?.addEventListener("click", () => {
    if(!confirm("ã“ã®CSVã®ã€Œä»Šæ—¥ã®å­¦ç¿’ãƒ­ã‚°ã€ã‚’0ã«æˆ»ã™ï¼Ÿï¼ˆé€šç®—ãƒ©ãƒ³ã‚­ãƒ³ã‚°ã¯æ¶ˆãˆã¾ã›ã‚“ï¼‰")) return;
    try{
      const date = jstDateKey();
      DAILY = { date, seen:0, correct:0, wrong:0, skip:0, updatedAt:0 };
      localStorage.setItem(dailyKeyFor(CURRENT_CSV_HASH, date), JSON.stringify(DAILY));
      upsertTodayInHistory();
      renderDailyUI();
      showFlash("good", "ä»Šæ—¥ã®å­¦ç¿’ãƒ­ã‚°ã‚’ãƒªã‚»ãƒƒãƒˆã—ãŸã‚ˆ");
    }catch(e){
      showFlash("bad", "ãƒªã‚»ãƒƒãƒˆã«å¤±æ•—ã—ãŸã‹ã‚‚");
    }
  });

  // æ—¥ä»˜ãŒå¤‰ã‚ã£ãŸã‚‰è‡ªå‹•ã§åˆ‡ã‚Šæ›¿ãˆï¼ˆã‚¿ãƒ–ã‚’é–‹ã„ãŸã¾ã¾ã§ã‚‚OKï¼‰
  setInterval(()=>{ try{
    const t = jstDateKey();
    if(DAILY && DAILY.date && DAILY.date !== t){
      loadDailyForCurrent();
    }
  }catch(e){} }, 5000);

  elShowResultsBtn.addEventListener("click", () => {
    // çµæœã‚’è¦‹ã‚‹æ™‚ã¯åœæ­¢çŠ¶æ…‹ã«ã™ã‚‹ï¼ˆé–‰ã˜ã¦ã‚‚è‡ªå‹•å†é–‹ã—ãªã„ï¼‰
    if (!isPaused) {
      pauseGame();
      elPauseBtn.textContent = "â–¶ å†é–‹";
    }
    showResults();
    showFlash("good", "ğŸ“Š çµæœã‚’è¡¨ç¤ºï¼ˆåœæ­¢ä¸­ï¼‰");
  });

  elPauseBtn.addEventListener("click", () => {
    if (!isPaused) {
      pauseGame();
      elPauseBtn.textContent = "â–¶ å†é–‹";
      return;
    }
    // ãƒ‘ãƒãƒ«å†…ã§å¾©ç¿’ã‚»ãƒƒãƒˆæ›´æ–°/èª­ã¿è¾¼ã¿ã‚’ã—ãŸå¾Œã¯ã€ã“ã“ã§åˆã‚ã¦ã‚¹ã‚¿ãƒ¼ãƒˆï¼ˆresetï¼‰ã™ã‚‹
    if (needsResetAfterOverlayAction) {
      needsResetAfterOverlayAction = false;
      elPauseBtn.textContent = "â¸ ä¸€æ™‚åœæ­¢";
      resetGame();
      return;
    }
    resumeGame();
    elPauseBtn.textContent = "â¸ ä¸€æ™‚åœæ­¢";
  });
function handleCloseResultClick(){
    elResultPanel.style.display = "none";
    if (isPaused) {
      showFlash("good", "çµæœã‚’é–‰ã˜ãŸã‚ˆï¼ˆåœæ­¢ä¸­ï¼‰");
    }
  }
  elCloseResult?.addEventListener("click", handleCloseResultClick);
  elCloseResultTop?.addEventListener("click", handleCloseResultClick);

elReviewMode.addEventListener("change", () => {
  updateReviewStatus();

  if (isPaused) {
    // ä¸­æ–­ä¸­ãªã‚‰ã‚²ãƒ¼ãƒ ã¯å†é–‹ã•ã›ãªã„
    needsResetAfterOverlayAction = true;
    overlayRequireManualResume = true;
    showFlash("good", "å¾©ç¿’ãƒ¢ãƒ¼ãƒ‰ã‚’å¤‰æ›´ã—ãŸã‚ˆï¼ˆä¸­æ–­ã®ã¾ã¾ï¼‰ã€‚å†é–‹ã™ã‚‹ã¨ãã¯ã€Œçµæœã‚’è¦‹ã‚‹ã€ã‚’æŠ¼ã—ã¦ã­");
    return;
  }

  resetGame();
});



  elPickReview.addEventListener("click", () => openReviewPicker());
  elSaveReview.addEventListener("click", () => saveReviewPicker());
  elClearReview.addEventListener("click", () => clearReviewSet());

  elResetStats?.addEventListener("click", () => {
    if (!confirm("ãƒ©ãƒ³ã‚­ãƒ³ã‚°ã‚’å…¨éƒ¨ãƒªã‚»ãƒƒãƒˆã™ã‚‹ï¼Ÿ")) return;
    try {
      Object.keys(localStorage)
        .filter(k => k.startsWith("hamaru_stats::"))
        .forEach(k => localStorage.removeItem(k));
    } catch {}
    // ç”»é¢ä¸Šã®ãƒ©ãƒ³ã‚­ãƒ³ã‚°è¡¨ç¤ºã‚‚å³ãƒªãƒ•ãƒ¬ãƒƒã‚·ãƒ¥ã—ãŸã„ã®ã§
    try { loadStatsFromStorage(); } catch {}
    showFlash("good", "ãƒ©ãƒ³ã‚­ãƒ³ã‚°ã‚’ãƒªã‚»ãƒƒãƒˆã—ã¾ã—ãŸ");
  });

elAutoPickWeak.addEventListener("click", () => autoPickWeakWords());
  elAutoPickWeakFromResults?.addEventListener("click", () => autoPickWeakWords());


  elAutoPickWeakGlobal?.addEventListener("click", () => {
    // å…¨CSVæ¨ªæ–­ã®è‹¦æ‰‹ã‚’ã€Œä»Šã®å¾©ç¿’ã‚»ãƒƒãƒˆã€ã«ä¸€ç™ºã§å…¥ã‚Œã‚‹
    // ç”»é¢ã¯é–‰ã˜ãšã€çµæœãŒè¦‹ãˆã‚‹ã‚ˆã†ã«å¿…è¦ãªã‚‰ãƒ©ãƒ³ã‚­ãƒ³ã‚°ã‚‚é–‹ã
    overlayRequireManualResume = true;
    applyGlobalWeakToReview();
    // ãƒ¦ãƒ¼ã‚¶ãƒ¼ãŒçŠ¶æ³ã‚’ç¢ºèªã§ãã‚‹ã‚ˆã†ã€ãƒ©ãƒ³ã‚­ãƒ³ã‚°ã‚‚è¡¨ç¤ºã—ã¦ãŠãï¼ˆä¸è¦ãªã‚‰é–‰ã˜ã¦OKï¼‰
    openOverlay(elGlobalWeakPanel);
    renderGlobalWeak();
  });

  elOpenGlobalWeak?.addEventListener("click", () => {
    openOverlay(elGlobalWeakPanel);
    renderGlobalWeak();
  });
  elCloseGlobalWeak?.addEventListener("click", () => {
    closeOverlay(elGlobalWeakPanel);
    try { const gf=document.getElementById("globalFlash"); if(gf) gf.style.display="none"; } catch {}
  });
  elRefreshGlobalWeak?.addEventListener("click", () => {
    overlayRequireManualResume = true;
    renderGlobalWeak();
    // ã€ŒæŠ¼ã—ãŸæ„Ÿã€ã‚’å‡ºã™ï¼ˆç·åˆãƒ‘ãƒãƒ«å†…ã«ã‚‚è¡¨ç¤ºã•ã‚Œã‚‹ï¼‰
    showFlash("good", "ãƒ©ãƒ³ã‚­ãƒ³ã‚°ã‚’æ›´æ–°ã—ãŸã‚ˆ");
  });
  elApplyGlobalWeakToReview?.addEventListener("click", () => { overlayRequireManualResume = true; applyGlobalWeakToReview(); });
  elLoadGlobalReview?.addEventListener("click", () => { overlayRequireManualResume = true; loadGlobalReviewIntoCurrent(); });

  elRounds.addEventListener("change", () => resetGame());
  elSecondsPerQ.addEventListener("change", () => resetGame());
  elReviewWeight.addEventListener("change", () => resetGame());

  
elCsvFile.addEventListener("change", async (e) => {
    const f = e.target.files && e.target.files[0];
    if (!f) return;

    // èª­ã¿è¾¼ã¿ã‚’ä¸€æ™‚ä¿ç•™ã—ã¦ã€ä¸Šæ›¸ãåˆ¤å®šãŒå¿…è¦ãªã‚‰ãƒ¢ãƒ¼ãƒ€ãƒ«ã§é¸ã¶
    let pending = null;

    try {
      const textRaw = await f.text();
      const text = normalizeCsvText(textRaw);
      const items = parseCSV(text);
      const newHash = await sha256Hex(text);

      if (items.length < 4) throw new Error("4æŠãªã®ã§ã€4èªä»¥ä¸Šå¿…è¦ã ã‚ˆ");

      const filename = (f && f.name) ? f.name : "ï¼ˆãƒ•ã‚¡ã‚¤ãƒ«åä¸æ˜ï¼‰";
      const prevHash = getLastHashForFilename(filename);

      pending = { items, filename, newHash, prevHash };

      const hasPrev = !!prevHash && prevHash !== "builtin";
      const isChanged = hasPrev && prevHash !== newHash;

      // ä»¥å‰ã®åŒåãƒ•ã‚¡ã‚¤ãƒ«ãŒå­˜åœ¨ã—ã¦ã€å†…å®¹ãŒå¤‰ã‚ã£ãŸã£ã½ã„å ´åˆã ã‘é¸ã°ã›ã‚‹
      if (isChanged) {
        const prevStatsCount = statsDataForHash(prevHash).length;
        const prevReviewCount = reviewDataForHash(prevHash).length;

        if (elOverwriteInfo) {
          elOverwriteInfo.innerHTML =
            `ãƒ•ã‚¡ã‚¤ãƒ«å: <span class="kbd">${escapeHtml(filename)}</span><br/>` +
            `å‰ã®æˆç¸¾: <b>${prevStatsCount}</b>èª / å‰ã®å¾©ç¿’: <b>${prevReviewCount}</b>èª<br/>` +
            `æ–°CSV: <b>${items.length}</b>èªï¼ˆå†…å®¹ãŒå¤‰ã‚ã£ãŸã®ã§é¸ã¹ã¾ã™ï¼‰`;
        }
        if (elOverwritePanel) elOverwritePanel.style.display = "block";

        // ã“ã“ã§å‡¦ç†ã‚’æ­¢ã‚ã¦ã€ãƒœã‚¿ãƒ³æŠ¼ä¸‹ã§ç¢ºå®šã•ã›ã‚‹
        const choose = await new Promise((resolve, reject) => {
          const cleanup = () => {
            elBtnInheritAll && (elBtnInheritAll.onclick = null);
            elBtnMergeCommon && (elBtnMergeCommon.onclick = null);
            elBtnResetNew && (elBtnResetNew.onclick = null);
            elBtnCancelLoad && (elBtnCancelLoad.onclick = null);
          };

          elBtnInheritAll && (elBtnInheritAll.onclick = () => { cleanup(); resolve("inherit"); });
          elBtnMergeCommon && (elBtnMergeCommon.onclick = () => { cleanup(); resolve("merge"); });
          elBtnResetNew && (elBtnResetNew.onclick = () => { cleanup(); resolve("reset"); });
          elBtnCancelLoad && (elBtnCancelLoad.onclick = () => { cleanup(); reject(new Error("ã‚­ãƒ£ãƒ³ã‚»ãƒ«")); });
        });

        if (elOverwritePanel) elOverwritePanel.style.display = "none";

        // é¸æŠã«å¿œã˜ã¦ã€å‰ãƒ‡ãƒ¼ã‚¿ã‚’æ–°ãƒãƒƒã‚·ãƒ¥ã¸ã‚³ãƒ”ãƒ¼ï¼ˆã¾ãŸã¯ãƒãƒ¼ã‚¸ï¼‰
        if (choose === "inherit") {
          writeStatsDataForHash(newHash, statsDataForHash(prevHash));
          writeReviewDataForHash(newHash, reviewDataForHash(prevHash));
        } else if (choose === "merge") {
          writeStatsDataForHash(newHash, mergeStatsCommon(statsDataForHash(prevHash), items));
          writeReviewDataForHash(newHash, mergeReviewCommon(reviewDataForHash(prevHash), items));
        } else {
          // reset: ä½•ã‚‚ã—ãªã„ï¼ˆæ–°ãƒãƒƒã‚·ãƒ¥ã¯ç©ºã§é–‹å§‹ï¼‰
        }
      }

      // ã“ã“ã‹ã‚‰å®Ÿéš›ã«åæ˜ 
      CURRENT_CSV_HASH = newHash;
      WORDS_ALL = items;
      CURRENT_CSV_NAME = filename;

      // â˜…ã‚¹ãƒãƒ›ã§ã€Œå˜èªãŒè¶³ã‚Šãªã„ã€ã‚’é˜²ãï¼šCSVèª­ã¿è¾¼ã¿ç›´å¾Œã¯ãƒ•ã‚£ãƒ«ã‚¿ãƒ¼ã‚’åˆæœŸåŒ–
      try{ if (elDeckSelect) elDeckSelect.value = "all"; }catch(e){}
      try{ if (elReviewMode) elReviewMode.value = "off"; }catch(e){}
      try{ REVIEW_SET = []; }catch(e){}
      try{ SELECTED_LANGS = new Set(); }catch(e){} // ã™ã¹ã¦
      try{ if (typeof renderLangFilterOptions === "function") renderLangFilterOptions(); }catch(e){}

      recordFilenameHash(filename, newHash, items.length);

      // ===== Save as "last CSV" (restore on next open) =====
      try{
        localStorage.setItem(LAST_CSV_NAME_KEY, filename);
        localStorage.setItem(LAST_CSV_HASH_KEY, newHash);
        localStorage.setItem(LAST_CSV_ITEMS_KEY, JSON.stringify(items));
        try{ const el = document.getElementById("lastCsvStatus"); if(el) el.textContent = `âœ… å‰å›CSVã¨ã—ã¦ä¿å­˜: ${filename}`; }catch(e){}
      }catch(e){
        try{ const el = document.getElementById("lastCsvStatus"); if(el) el.textContent = "âš ï¸ å‰å›CSVã®ä¿å­˜ã«å¤±æ•—ï¼ˆå®¹é‡ä¸Šé™ã®å¯èƒ½æ€§ï¼‰"; }catch(e){}
      }


      elCsvStatus.textContent = `ç¾åœ¨ã®CSV: ${CURRENT_CSV_NAME}ï¼ˆ${items.length}èªï¼‰`;
  try { if (typeof renderLangFilterOptions === "function") renderLangFilterOptions(); } catch(e) {}
      applyDeckFilter();

      // å¾©ç¿’/æˆç¸¾ã®å¾©å…ƒ
      REVIEW_SET = [];
      loadReviewFromStorage();
      loadStatsFromStorage();

      updateReviewStatus();
      resetGame();
      renderHud();
      try { loadDailyForCurrent(); } catch(e) {}
      showFlash("good", "CSVã‚’åæ˜ ã—ãŸã‚ˆï¼");
    } catch (err) {
      if (String(err && err.message).includes("ã‚­ãƒ£ãƒ³ã‚»ãƒ«")) {
        showFlash("bad", "èª­ã¿è¾¼ã¿ã‚’ã‚­ãƒ£ãƒ³ã‚»ãƒ«ã—ãŸã‚ˆ");
      } else {
        elCsvStatus.textContent = `èª­ã¿è¾¼ã¿å¤±æ•—: ${err.message || err}`;
        showFlash("bad", `CSVã‚¨ãƒ©ãƒ¼: ${err.message || err}`);
      }
      if (elOverwritePanel) elOverwritePanel.style.display = "none";
    } finally {
      elCsvFile.value = "";
    }
  });


  // TTS UI
  elRate.addEventListener("input", () => elRateLabel.textContent = Number(elRate.value).toFixed(2));
  elVolume.addEventListener("input", () => elVolLabel.textContent = Number(elVolume.value).toFixed(2));
  elSpeak.addEventListener("click", () => speakCurrent());
  elStopSpeak.addEventListener("click", () => stopSpeech());

  // Force clear TTS lock (for rare stuck states)
  const elClearTtsLock = document.getElementById("clearTtsLock");
  elClearTtsLock?.addEventListener("click", () => {
    try{ window.speechSynthesis && window.speechSynthesis.cancel(); }catch(e){}
    try{ localStorage.removeItem(TTS_LOCK_KEY); }catch(e){}
    try{ releaseTtsLock(); }catch(e){}
    try{ updateTtsHud(); }catch(e){}
// reflect lock changes from other tabsï¼ˆ1å›ã ã‘èµ·å‹•ï¼‰
try{
  if (!window.__ttsHudTimer) {
    window.__ttsHudTimer = setInterval(() => {
      try { updateTtsHud(); } catch(e) {}
    }, 1000);
  }
}catch(e){}






    showFlash("good", "éŸ³å£°ãƒ­ãƒƒã‚¯ã‚’è§£é™¤ã—ãŸã‚ˆï¼ˆå¿…è¦ãªã‚‰å†ç”Ÿã—ã¦ã¿ã¦ã­ï¼‰");
  });


  
  // Last CSV: forget button
  try{
    const elForgetLastCsv = document.getElementById("forgetLastCsv");
    elForgetLastCsv?.addEventListener("click", () => {
      if (!confirm("å‰å›èª­ã¿è¾¼ã‚“ã CSVã‚’å¿˜ã‚Œã¦ã€å†…è”µãƒ‡ãƒ¼ã‚¿ã«æˆ»ã—ã¾ã™ã‹ï¼Ÿ")) return;
      forgetLastCsv();
    });
  }catch(e){}

// Keyboard shortcuts
  window.addEventListener("keydown", (e) => {
    if (overlayDepth > 0) return;
    const k = e.key.toLowerCase();
    if (k >= "1" && k <= "4") {
      const idx = parseInt(k, 10) - 1;
      const btn = elChoices.querySelectorAll("button.choice")[idx];
      if (btn && !btn.disabled) btn.click();
    }
    if (k === "s") elSkip.click();
    if (k === "r") elRestart.click();
    if (k === "p") speakCurrent();
    if (k === "x") stopSpeech();
  });

  // voices can load async
  if (window.speechSynthesis) {
    window.speechSynthesis.onvoiceschanged = () => listVoices();
  }

  
// ===== Last CSV persistence (mobile-friendly) =====
// ã‚¹ãƒãƒ›ã§ã‚¿ãƒ–ã‚’é–‰ã˜ã¦ã‚‚ã€Œå‰å›èª­ã¿è¾¼ã‚“ã CSVã€ã‚’å¾©å…ƒã§ãã‚‹ã‚ˆã†ã«ä¿å­˜ã—ã¾ã™ã€‚
// â€»localStorageå®¹é‡ã«ã‚ˆã‚Šã€è¶…å·¨å¤§CSVã¯ä¿å­˜ã§ããªã„å ´åˆãŒã‚ã‚Šã¾ã™ï¼ˆãã®æ™‚ã¯å†…è”µã«æˆ»ã‚Šã¾ã™ï¼‰ã€‚
const LAST_CSV_NAME_KEY  = "hamaru_last_csv_name";
const LAST_CSV_HASH_KEY  = "hamaru_last_csv_hash";
const LAST_CSV_ITEMS_KEY = "hamaru_last_csv_items";

function tryRestoreLastCsv(){
  try{
    const itemsRaw = localStorage.getItem(LAST_CSV_ITEMS_KEY);
    const name = localStorage.getItem(LAST_CSV_NAME_KEY) || "";
    const hash = localStorage.getItem(LAST_CSV_HASH_KEY) || "";
    if(!itemsRaw) return false;
    const items = JSON.parse(itemsRaw);
    if(!Array.isArray(items) || items.length < 4) return false;

    // Restore
    CURRENT_CSV_NAME = name || "å‰å›ã®CSV";
    CURRENT_CSV_HASH = hash || "restored";
    WORDS_ALL = items;

    // UI
    try{ if (elCsvStatus) elCsvStatus.textContent = `ç¾åœ¨ã®CSV: ${CURRENT_CSV_NAME}ï¼ˆ${WORDS_ALL.length}èªï¼‰`; }catch(e){}
    try{ const el = document.getElementById("lastCsvStatus"); if(el) el.textContent = `âœ… å‰å›ã®CSVã‚’è‡ªå‹•å¾©å…ƒ: ${CURRENT_CSV_NAME}`; }catch(e){}
    return true;
  }catch(e){
    return false;
  }
}

function forgetLastCsv(){
  try{
    localStorage.removeItem(LAST_CSV_ITEMS_KEY);
    localStorage.removeItem(LAST_CSV_NAME_KEY);
    localStorage.removeItem(LAST_CSV_HASH_KEY);
  }catch(e){}
  try{
    const el = document.getElementById("lastCsvStatus");
    if(el) el.textContent = "å‰å›CSVã‚’å¿˜ã‚Œã¾ã—ãŸï¼ˆå†…è”µãƒ‡ãƒ¼ã‚¿ã«æˆ»ã—ã¾ã™ï¼‰";
  }catch(e){}
  // å†…è”µã¸æˆ»ã™ã«ã¯ãƒªãƒ­ãƒ¼ãƒ‰ãŒä¸€ç•ªç¢ºå®Ÿï¼ˆçŠ¶æ…‹/ã‚¿ã‚¤ãƒãƒ¼/ãƒ­ãƒƒã‚¯ãŒçµ¡ã‚€ãŸã‚ï¼‰
  try{ location.reload(); }catch(e){}
}


// å¾©å…ƒã—ãŸCSVã«åˆã‚ã›ã¦ã€ãƒ‡ãƒƒã‚­/æˆç¸¾/å¾©ç¿’/å­¦ç¿’ãƒ­ã‚°/UIã‚’ã¾ã¨ã‚ã¦å†åŒæœŸ
function restoreAllFromLastCsvIfNeeded(){
  const before = CURRENT_CSV_HASH;
  const restored = tryRestoreLastCsv();
  if(!restored) return false;

  // ã“ã“ã§ CURRENT_CSV_HASH / WORDS_ALL / CURRENT_CSV_NAME ãŒå¾©å…ƒæ¸ˆã¿
  try{ applyDeckFilter(); }catch(e){}
  try{ REVIEW_SET = []; }catch(e){}
  try{ loadReviewFromStorage(); }catch(e){}
  try{ loadStatsFromStorage(); }catch(e){}
  try{ updateReviewStatus(); }catch(e){}
  try{ if (typeof renderLangFilterOptions === "function") renderLangFilterOptions(); }catch(e){}
  try{ loadDailyForCurrent(); }catch(e){}

  // HUDæ›´æ–°
  try{ renderHud(); }catch(e){}
  return true;
}

// =========================
  // Init
  // =========================
  // âœ… å‰å›CSVã‚’æœ€å„ªå…ˆã§å¾©å…ƒï¼ˆã‚¹ãƒãƒ›ã®ã€Œæˆ»ã‚‹ã€ã€Œå†è¡¨ç¤ºã€ã€Œå†èµ·å‹•ã€å¯¾ç­–ï¼‰
  const __restored = restoreAllFromLastCsvIfNeeded();

  // bfcacheï¼ˆæˆ»ã‚‹/é€²ã‚€ã§ãƒšãƒ¼ã‚¸ãŒã€Œå¾©å¸°ã€ã—ãŸæ™‚ï¼‰ã«ã‚‚å¾©å…ƒã‚’ã‹ã‘ã‚‹
  window.addEventListener("pageshow", (ev) => {
    try{
      // persisted=true ã®ã¨ãã¯ bfcache ã‹ã‚‰å¾©å¸°
      // persisted=false ã§ã‚‚ Android/Chrome ã¯æˆ»ã‚‹ã§çŠ¶æ…‹ãŒã‚ºãƒ¬ã‚‹ã“ã¨ãŒã‚ã‚‹ã®ã§æ¯å›ãƒã‚§ãƒƒã‚¯ã™ã‚‹
      const ok = restoreAllFromLastCsvIfNeeded();
      if(ok){
        // å¾©å…ƒã•ã‚ŒãŸã‚‰ã€ã„ã£ãŸã‚“ã‚²ãƒ¼ãƒ ã‚’ãƒªã‚»ãƒƒãƒˆã—ã¦æ•´åˆæ€§ã‚’å–ã‚‹
        try{ resetGame(); }catch(e){}
      }
    }catch(e){}
  });

  if(!__restored){
    // å¾©å…ƒã§ããªã‹ã£ãŸå ´åˆã¯å†…è”µãƒ‡ãƒ¼ã‚¿ã§é€šå¸¸åˆæœŸåŒ–
    applyDeckFilter();
    loadReviewFromStorage();
    loadStatsFromStorage();
    updateReviewStatus();
  }

  listVoices();
  elRateLabel.textContent = Number(elRate.value).toFixed(2);
  elVolLabel.textContent = Number(elVolume.value).toFixed(2);
  elCsvStatus.textContent = `ç¾åœ¨ã®CSV: ${CURRENT_CSV_NAME}ï¼ˆ${WORDS_ALL.length}èªï¼‰`;

  try { loadDailyForCurrent(); } catch(e) {}

  try { if (typeof renderLangFilterOptions === "function") renderLangFilterOptions(); } catch(e) {}
  // =========================
  // è¨€èªãƒ•ã‚£ãƒ«ã‚¿ãƒ¼ï¼ˆãƒãƒƒãƒ—UIï¼‰åˆæœŸåŒ–
  // =========================
  try {
    // åˆæœŸã¯å…¨éƒ¨ONï¼ˆè¦‹ãŸç›®ãŒåˆ†ã‹ã‚Šã‚„ã™ã„ï¼‰ã€‚åŠ¹æœã¯ã€Œã™ã¹ã¦å¯¾è±¡ã€ã¨åŒã˜ã€‚
    try { SELECTED_LANGS = new Set(getKnownLangs()); } catch(e) {}

    if (typeof renderLangFilterOptions === "function") renderLangFilterOptions();
    if (elLangAll) {
      elLangAll.addEventListener("click", () => {
        // å…¨é¸æŠ = ãƒãƒƒãƒ—ã‚’å…¨éƒ¨ONï¼ˆè¦‹ãŸç›®ã®å…¨é¸æŠï¼‰
        try { SELECTED_LANGS = new Set(getKnownLangs()); } catch(e) { SELECTED_LANGS = new Set(); }
        renderLangFilterOptions();
        showFlash("good", "è¨€èª: å…¨é¸æŠã«ã—ãŸã‚ˆ");
      });
    }
    if (elLangClear) {
      elLangClear.addEventListener("click", () => {
        // ã‚¯ãƒªã‚¢=ã™ã¹ã¦ï¼ˆè¿·å­é˜²æ­¢ï¼‰
        SELECTED_LANGS = new Set();
        renderLangFilterOptions();
        // åå¿œãŒåˆ†ã‹ã‚‹ã‚ˆã†ã«ã€å¿…ãšãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’å‡ºã™
        const langs = (typeof getKnownLangs === "function") ? getKnownLangs() : [];
        if (!langs || langs.length === 0) {
          if (elLangFilterStatus) elLangFilterStatus.textContent = "è¨€èª: ã™ã¹ã¦ï¼ˆâ€»CSVã‚’èª­ã¿è¾¼ã‚€ã¨è¡¨ç¤ºã•ã‚Œã‚‹ã‚ˆï¼‰";
          showFlash("good", "ã¾ã è¨€èªãŒè¦‹ã¤ã‹ã‚‰ãªã„ã‚ˆã€‚langåˆ—ã¤ãCSVã‚’èª­ã¿è¾¼ã‚“ã§ã­");
        } else {
          if (elLangFilterStatus) elLangFilterStatus.textContent = "è¨€èª: ã™ã¹ã¦";
          showFlash("good", "è¨€èªãƒ•ã‚£ãƒ«ã‚¿ãƒ¼ã‚’ã‚¯ãƒªã‚¢ã—ãŸã‚ˆï¼ˆ= ã™ã¹ã¦å¯¾è±¡ï¼‰");
          try { elLangClear.classList.add("langClearPulse"); setTimeout(()=>elLangClear.classList.remove("langClearPulse"), 250); } catch(e) {}
        }
      });
    }
  } catch(e) { console.error(e); }

  renderHud();
  resetGame();


// ===== TTS HUD =====
function updateTtsHud(){
  const pill = document.getElementById("ttsHudPill");
  if(!pill) return;

  let lock = null;
  try{
    const raw = localStorage.getItem(TTS_LOCK_KEY);
    if(!raw){
      lock = null;
    }else if(raw[0] !== "{"){
      // æ—§å½¢å¼ï¼ˆidæ–‡å­—åˆ—ã®ã¿ï¼‰
      lock = { id: raw, ts: Date.now() };
    }else{
      lock = JSON.parse(raw);
      // æœŸé™åˆ‡ã‚Œãªã‚‰ã€Œæœªä½¿ç”¨ã€æ‰±ã„ï¼ˆè¡¨ç¤ºãŒèµ¤ã®ã¾ã¾å›ºã¾ã‚‹ã®ã‚’é˜²ãï¼‰
      if(lock && lock.ts && (Date.now() - lock.ts) > (typeof LOCK_TTL_MS !== "undefined" ? LOCK_TTL_MS : 12000)){
        lock = null;
      }
    }
  }catch(e){
    lock = null;
  }

  pill.classList.remove("free","active","waiting");

  if(!lock || !lock.id){
    pill.textContent = "ğŸ™ éŸ³å£°: æœªä½¿ç”¨";
    pill.classList.add("free");
  }else if(lock.id === TAB_ID){
    pill.textContent = "ğŸ™ éŸ³å£°: ã—ã‚ƒã¹ã‚Œã‚‹";
    pill.classList.add("active");
  }else{
    pill.textContent = "ğŸ™ éŸ³å£°: å¾…æ©Ÿä¸­";
    pill.classList.add("waiting");
  }
}
try{ updateTtsHud(); }catch(e){}
function setVh(){
  document.documentElement.style.setProperty('--vh', (window.innerHeight * 0.01) + 'px');
}
setVh();
addEventListener('resize', setVh);
addEventListener('orientationchange', setVh);

</script>
</body>
</html>
